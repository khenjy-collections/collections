<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from 127.0.0.1:1313/docs/searching/ by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 18 Dec 2023 19:41:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Searching | Notepad&#43;&#43; User Manual</title>


<link rel="stylesheet" href="../../book.min.6c7317d2e8552a0ac3ea8fd4ba500c3dfb1cc9c74e7afd73eee6d729751fad30.css">


<script defer src="../../search.min.846c386b21b231fe6d74b69f2b1e15f64ff47ab2e34867cee60513e0dd296443.js"></script>



<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151884174-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-151884174-1');
</script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="./index.html">Notepad&#43;&#43; User Manual</a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly hidden />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    

  
  





 
  
    

  <ul>
    
    
    <li>
      

  <a href="../getting-started/index.html" >
      Getting started
  </a>


    </li>
    
    <li>
      

  <a href="../files/index.html" >
      Working with Files
  </a>


    </li>
    
    <li>
      

  <a href="../editing/index.html" >
      Editing
  </a>


    </li>
    
    <li>
      

  <a href="index.html"  class="active">
      Searching
  </a>


    </li>
    
    <li>
      

  <a href="../views/index.html" >
      Views
  </a>


    </li>
    
    <li>
      

  <a href="../session/index.html" >
      Sessions, Workspaces, and Projects
  </a>


    </li>
    
    <li>
      

  <a href="../function-list/index.html" >
      Function List
  </a>


    </li>
    
    <li>
      

  <a href="../auto-completion/index.html" >
      Auto-Completion
  </a>


    </li>
    
    <li>
      

  <a href="../programing-languages/index.html" >
      Highlighting - Built-in Languages
  </a>


    </li>
    
    <li>
      

  <a href="../user-defined-language-system/index.html" >
      Highlighting - User Defined Languages
  </a>


    </li>
    
    <li>
      

  <a href="../macros/index.html" >
      Macros - Task Automation
  </a>


    </li>
    
    <li>
      

  <a href="../run-menu/index.html" >
      Running External Commands
  </a>


    </li>
    
    <li>
      

  <a href="../plugins/index.html" >
      Plugins
  </a>


    </li>
    
    <li>
      

  <a href="../plugin-communication/index.html" >
      Plugin Communication
  </a>


    </li>
    
    <li>
      

  <a href="../command-prompt/index.html" >
      Command Line Arguments
  </a>


    </li>
    
    <li>
      

  <a href="../preferences/index.html" >
      Preferences
  </a>


    </li>
    
    <li>
      

  <a href="../config-files/index.html" >
      Configuration Files Details
  </a>


    </li>
    
    <li>
      

  <a href="../themes/index.html" >
      Themes
  </a>


    </li>
    
    <li>
      

  <a href="../binary-translation/index.html" >
      Localization - User Interface Translation
  </a>


    </li>
    
    <li>
      

  <a href="../upgrading/index.html" >
      Upgrading
  </a>


    </li>
    
    <li>
      

  <a href="../shell-extension/index.html" >
      Right Click - Edit With Notepad&#43;&#43;
  </a>


    </li>
    
    <li>
      

  <a href="../ghost-typing/index.html" >
      Ghost Typing
  </a>


    </li>
    
    <li>
      

  <a href="../other-resources/index.html" >
      Other Resources
  </a>


    </li>
    
    <li>
      

  <a href="../history/index.html" >
      User Manual History
  </a>


    </li>
    
    <li>
      

  <a href="../license/index.html" >
      Copyright &amp; License
  </a>


    </li>
    
  </ul>


  











</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>Searching</strong>
</header>

      
<article class="markdown">

<p>There are multiple methods to search (and replace) text in files. You can also mark search results with a bookmark on their lines, or highlight the textual results themselves.  Generating a count of matches is also possible.</p>

<p>There are three main built-in search mechanisms: the standard (dialog-based) Find / Replace / Find In Files / Mark, the dialog-free Next / Previous search-navigation, and the Incremental Search.</p>

<p>All keyboard shortcuts mentioned below are the default values, but are configurable in the <a href="../preferences/index.html#shortcut-mapper">Shortcut Mapper</a>.  You can see the active shortcut for any menu item in the menu entry, or in the Shortcut Mapper.</p>

<h2 id="dialog-based-searching">Dialog-based Searching</h2>

<p>There is a &ldquo;Find&rdquo; dialog box. This dialog box has one tab for each of the following features:</p>

<ul>
<li><p><strong>Find</strong> tab: Gives access to searching and counting.<br />
It can be invoked directly with <strong>Search &gt; Find</strong> or the keyboard shortcut <code>Ctrl+F</code>.</p></li>

<li><p><strong>Replace</strong> tab: Similar to <strong>Find</strong> tab, but allows you to replace the matched text after it&rsquo;s found.<br />
It can be invoked directly with <strong>Search &gt; Replace</strong> or the keyboard shortcut <code>Ctrl+H</code>.</p></li>

<li><p><strong>Find in Files</strong> tab: Allows you to search and replace in multiple files with one action. The files used for the operation are specified by a directory.<br />
It can be invoked directly with <strong>Search &gt; Find in Files</strong> or the keyboard shortcut <code>Ctrl+Shift+F</code>.</p></li>

<li><p><strong>Find in Projects</strong> tab: Similar to <strong>Find in Files</strong>, but Project Panel files are used instead of files from a directory.<br />
It can be invoked over the context menu of the first line of a Project Panel.</p></li>

<li><p><strong>Mark</strong> tab: Allows you to highlight all occurrences of the search target in the current document permanently.<br />
It can be invoked directly with <strong>Search &gt; Mark</strong> or the keyboard shortcut <code>Ctrl+M</code>.</p></li>
</ul>

<p><em>Note:</em>  Prior to v8.1.3, doing any of those keystrokes (<code>Ctrl+F</code>, <code>Ctrl+H</code>, <code>Ctrl+Shift+F</code>, or <code>Ctrl+M</code>) once would open the Find dialog or bring it into focus; from the main dialog, hitting <code>Ctrl+F</code> would re-center the dialog (no matter which tab of the dialog you were on); but you could not use the shortcuts for the other tabs to switch between the tabs.  In v8.1.3 through v8.3.2, once the dialog was active and in focus, hitting the keystrokes would switch between the tabs on that dialog; however, these versions of Notepad++ would <em>not</em> re-center the dialog if you hit <code>Ctrl+F</code> again.  Starting in v8.3.3, the first hit of one of those shortcuts would bring up the dialog or bring it into focus; from there, hitting one of the <em>other</em> shortcuts would change tabs in the dialog (as with v8.1.3), but hitting the shortcut for the tab you are already on will re-center the dialog (so <code>Ctrl+F, Ctrl+F</code> will center the Find dialog, <code>Ctrl+H, Ctrl+H</code> will re-center the Replace dialog, and so on), giving you the full functionality of both tab-switching and dialog-centering.</p>

<p><em>Note:</em>  Use of some &ldquo;Find&rdquo; family features can cause the window to close after a successful search (one or more &ldquo;hits&rdquo;).  Some users dislike this and wish for the &ldquo;Find&rdquo; window to always remain open.  This may be achieved by use of the optional setting: <strong>Settings &gt; Preferences &gt; Searching &gt; ☐ Find dialog remains open after search that outputs to results window</strong>.</p>

<p><em>Note:</em>  Search option choices made by the user are remembered across invocations of Notepad++.</p>

<p><em>Note:</em>  To get a smaller version of the Dialog, with many of the options hidden, use the <strong>∧</strong> button in the lower right corner; to show the full dialog again, use the <strong>∨</strong> button.  (new to v8.4.5)</p>

<h3 id="find-replace-tabs">Find / Replace tabs</h3>

<p>All the search dialogs have certain features in common, though some are not available (greyed out) under certain circumstances.</p>

<ul>
<li><strong>Find what</strong> edit box with dropdown history: This is the text you are searching for.</li>

<li><p><strong>Replace with</strong> edit box with dropdown history: This is the text that will replace what was matched.</p></li>

<li><p><strong>☐ In selection</strong>: If you have a region of text selected, and this option is checked, <strong>Count</strong>, <strong>Replace All</strong>, or <strong>Mark All</strong> will only operate within the selected text, rather than the whole document (other buttons, such as <strong>Find Next</strong>, will continue to work on the whole document).</p></li>

<li><p><strong>☐ Backward direction</strong>: Normally, searches go forward (down the page); with this option, they will go backward (up the page).</p></li>

<li><p><strong>☐ Match whole word only</strong>: If checked, searches will only match if the result is a whole word (so &ldquo;it&rdquo; will not be found inside &ldquo;hitch&rdquo;).</p>

<ul>
<li>For ASCII text (text that only has newlines, tabs, and characters with codepoints 32 - 126):

<ul>
<li>If the left and right characters of your search string are both &ldquo;word characters&rdquo; (letters, numbers, underscore, and <a href="https://npp-user-manual.org/docs/preferences/#delimiter" title="NPP User Manual: Delimiter settings">optionally</a> additional characters set by your preferences), then <strong>Match whole word only</strong> will only allow a match if the characters to the left and right of the match are <em>non</em>-word-characters or spaces or the beginning or ending of the line.</li>
<li>If the left and right characters of your search string are both non-word characters (so <em>not</em> letters, numbers, underscore, and <a href="https://npp-user-manual.org/docs/preferences/#delimiter" title="NPP User Manual: Delimiter settings">optionally</a> additional characters set by your preferences), then the text to the left and right of your match must be word characters, spaces, and/or beginning or ending of the line.</li>
<li>If the left of your search string is a word character and the right is not (or vice versa), then the characters to the left and right must be of the opposite type, or be spaces, or be the beginning/ending of a line.</li>
</ul></li>
<li>For non-ASCII text, the general concepts are the same; however, some edge cases may behave differently than you expect, and with thousands of possible Unicode characters and millions of combinations of pairs of Unicode characters, this manual <em>cannot</em> contain a full description.</li>
<li>With either ASCII or full Unicode text, if you want <em>full</em> control of what counts as a &ldquo;word&rdquo; or a &ldquo;word boundary&rdquo;, use <strong>Search Mode</strong> = <strong>Regular Expression</strong> instead of using <strong>Normal</strong> with <strong>Match whole word only</strong>: Regular expressions allow you full and precise control of what is allowed before and after what <em>you</em> consider a &ldquo;whole word&rdquo;, rather than relying on someone else&rsquo;s definition.</li>
</ul></li>

<li><p><strong>☐ Match case</strong>: If checked, searches must match in case (so a search for &ldquo;it&rdquo; will not find &ldquo;It&rdquo; or &ldquo;IT&rdquo;).  The regular expression <code>i</code> flag will override this checkbox, where <code>(?i)</code> will make the search case insensitive, and <code>(?-i)</code> will make the search case sensitive.</p></li>

<li><p><strong>☐ Wrap Around</strong>: If checked, when the search reaches the end of the document, it will wrap around to the beginning and continue searching.</p></li>

<li><p><strong>Search Mode</strong>: This determines how the text in the <strong>Find what</strong> and <strong>Replace with</strong> text fields will be treated.</p>

<ul>
<li><strong>☐ Normal</strong>: All text is treated literally.</li>
<li><strong>☐ Extended (\n, \r, \t, \0, \x&hellip;)</strong>: Use certain &ldquo;wildcards&rdquo;, as described in <a href="#extended-search-mode">Extended Search Mode (below)</a>.</li>
<li><strong>☐ Regular Expression</strong>: Uses the Boost regular expression engine to perform very powerful search and replace actions, as explained in <a href="#regular-expressions">Regular Expressions (below)</a>.

<ul>
<li><strong>☐ . matches newline</strong>: In regular expressions, with this unchecked, the regular expression <code>.</code> matches any character except the line-ending characters (carriage-return and/or linefeed); with this checked, <code>.</code> also matches the line-ending characters.  As an alternative to using this checkbox, begin the <strong>Find what</strong> box text with <code>(?-s)</code> to obtain the unchecked behavior of <strong>. matches newline</strong>, or with <code>(?s)</code> to get its checked behavior.</li>
</ul></li>
</ul></li>

<li><p><strong>☐ Transparency</strong>: These settings affect the dialog box.  Normally, the dialog box is opaque (can&rsquo;t see the text beneath), but with these settings, it can be made semi-transparent (can partially see the text beneath).</p>

<ul>
<li><strong>☐ On losing focus</strong>: If this is chosen, the dialog will be opaque when you are actively in the dialog box, but if you click in the Notepad++ window, the dialog will become semi-transparent.</li>
<li><strong>☐ Always</strong>: If this is chosen, the dialog will be semi-transparent, even when you are actively in the dialog box.</li>
<li>Slider Bar: Sliding it right makes the dialog more opaque; sliding it left makes it more transparent.

<ul>
<li>Be careful when sliding it to the extreme left: You might not be able to see the dialog box anymore.</li>
<li>By (temporarily) setting it to <strong>Always</strong>, you can see how transparent the dialog will be while moving the slider, which can help prevent making it too transparent to see.</li>
</ul></li>
</ul></li>
</ul>

<p>The various action buttons available include:</p>

<ul>
<li><strong>Find Next</strong>: Finds the next matching text.

<ul>
<li><strong>☐</strong> The unlabeled checkbox near the <strong>Find Next</strong> button changes the single <strong>Find Next</strong> button into two buttons with <strong>▲</strong> and <strong>▼ Find Next</strong> triangle arrows, which mean &ldquo;search backward / find previous&rdquo; and &ldquo;search forward / find next&rdquo;.  Hovering over this checkbox with the mouse will, after a slight pause in movement, pop up a tooltip indicating &ldquo;2 find buttons mode&rdquo; to remind you of its utility.</li>
</ul></li>
<li><strong>Count</strong>: Counts how many matches are in the entire document, or in the specified direction, or possibly <strong>☐ In selection</strong>, and shows that count in the message section at the bottom of the dialog box.</li>
<li><strong>Find All in All Opened Documents</strong>: Lists all the search-results in a new <strong>Search results</strong> window; searches through all the file buffers currently open in Notepad++.</li>
<li><strong>Find All in Current Document</strong>: Lists all the search-results in a new <strong>Search results</strong> window; only searches the active document buffer.</li>

<li><p><strong>Close</strong>: Closes the search dialog.</p></li>

<li><p><strong>Replace</strong>: Replaces the currently-selected match.  (If no match is currently selected, it behaves like <strong>Find Next</strong> and just highlights the next match in the specified direction.)</p>

<ul>
<li>On the <strong>Replace</strong> tab, there is an up-down arrow button <strong>⇅</strong> near the <strong>Find what</strong> and <strong>Replace with</strong> inputs which swaps the values of those two inputs, to make it easy to do the opposite replacement of the one that&rsquo;s active.  Please note that not all <a href="#substitutions">regular expression substitution escapes</a> will have the same meaning when swapped into the search expression. (The swap feature was added in v8.2.1.)</li>
<li>Notepad++ v8.5.1 extends this swap feature: You can right-click on that button to choose one of three actions:

<ul>
<li><strong>⇅ Swap Find with Replace</strong>: Moves the <strong>Find what</strong> to <strong>Replace with</strong> input, and the old <strong>Replace with</strong> gets moved to the <strong>Find what</strong> input.</li>
<li><strong>⤵ Copy from Find to Replace</strong>: Copies the <strong>Find what</strong> text to the <strong>Replace with</strong> input, but does not change the <strong>Find what</strong> input.</li>
<li><strong>⤴ Copy from Replace to Find</strong>: Copies the <strong>Replace with</strong> text to the <strong>Find what</strong> input, but does not change the <strong>Replace with</strong> input.</li>
<li>After selecting an action from this menu, that action is immediately performed, and the button changes its icon to indicate the new mode for that button.</li>
</ul></li>
<li>Notepad++ v8.5.2 replaces the right-click menu with a pull-down menu (▼) on the swap button, to make it more obvious that it can be changed.</li>
</ul></li>

<li><p><strong>Replace All</strong>: With <strong>☑ Wrap Around</strong> checked, it makes one pass through the active document, from the very top to the very bottom, and replaces all occurrences found.  With <strong>☐ Wrap Around</strong> unchecked, it searches from the caret to the end of the file (if <strong>☐ Backward direction</strong> is unchecked) or from the beginning of the file to the caret (if <strong>☑ Backward direction</strong> is checked) and replaces all occurrences found in that region.</p>

<ul>
<li>NOTE: For regular expressions, this will be equivalent to running the regular expression multiple times, which is <em>not</em> the same as running with the <code>/g</code> global flag enabled that is available in the regular expression engines of some programming-languages.</li>

<li><p>To clarify the <strong>Replace All</strong> results, depending on the condition of the various settings:</p>

<table>
<thead>
<tr>
<th align="center">Previous<br>Selection</th>
<th align="center">Wrap Around</th>
<th align="center">Backward Direction</th>
<th align="center">In Selection</th>
<th align="left">Range</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">NO</td>
<td align="center">OFF</td>
<td align="center">OFF</td>
<td align="center">OFF</td>
<td align="left">From  CARET location      to  END of file</td>
</tr>

<tr>
<td align="center">YES</td>
<td align="center">OFF</td>
<td align="center">OFF</td>
<td align="center">OFF</td>
<td align="left">From  START of selection  to  END of file</td>
</tr>

<tr>
<td align="center">NO</td>
<td align="center">OFF</td>
<td align="center">ON</td>
<td align="center">OFF</td>
<td align="left">From  START of file       to  CARET location</td>
</tr>

<tr>
<td align="center">YES</td>
<td align="center">OFF</td>
<td align="center">ON</td>
<td align="center">OFF</td>
<td align="left">From  START of file       to  END of selection</td>
</tr>

<tr>
<td align="center">YES</td>
<td align="center">-/-</td>
<td align="center">-/-</td>
<td align="center">ON</td>
<td align="left">From  START of selection  to  END of selection</td>
</tr>

<tr>
<td align="center">-/-</td>
<td align="center">ON</td>
<td align="center">-/-</td>
<td align="center">OFF</td>
<td align="left">From  START of file       to  END of file</td>
</tr>
</tbody>
</table>

<p><em>The <strong>Previous Selection</strong> column indicates that a range of text has been selected already. The <strong>Wrap Around</strong> and <strong>Backward Direction</strong> and <strong>In Selection</strong> columns refer to the setting of the checkboxes described above. The <strong>Range</strong> column describes the range of the document that is affected by the <strong>Replace All</strong>. A value of &ldquo;-/-&rdquo; means that the setting does not influence the outcome for that combination of conditions.</em></p></li>
</ul></li>

<li><p><strong>Replace All in All Opened Documents</strong>: Same as <strong>Replace All</strong>, but goes through all the documents open in Notepad++, not just the active document.</p></li>
</ul>

<p>The above actions may be initiated via mouse by pressing the appropriate button, or via special <code>Alt</code> key combinations.  Notepad++ can underline a single character in the text of <em>most</em> of the buttons (oftentimes, it is automatic; however, if you ever cannot see the underlines, then just press the <code>Alt</code> key, and they will appear).  Pressing <code>Alt</code> and one of the underlined characters will be the same as pressing the same button with the mouse, i.e., the chosen action will be initiated.  The <code>Alt</code> technique works for controls other than buttons as well, e.g., a checkbox control can be checked/unchecked via pressing its <code>Alt</code> key command.</p>

<p><strong>Find Next</strong> has a special way of being invoked by keyboard control.  Pressing <code>Enter</code> when the Find dialog has input focus will initiate the <strong>Find Next</strong> command in the direction indicated by <strong>Backward direction</strong>.  Pressing <code>Shift+Enter</code> when the Find dialog has input focus will run the <strong>Find Next</strong> in the <strong><em>opposite</em></strong> direction as that indicated by <strong>Backward direction</strong>.  Hovering over the <strong>Find Next</strong> button with the mouse will, after a slight delay, pop up a tool tip indicating <em>Use Shift+Enter to search in the opposite direction</em> as a reminder of this capability.</p>

<p>When a find-family function is invoked via the Search menu, toolbar, or keyboard combination, the word at the caret (or the selected text, if any) is automatically copied into the <strong>Find what</strong> edit box.  This behavior cannot be disabled; it always happens.  To avoid this in a limited way, use the <em>mouse</em> to switch to an already-open Find dialog, or make sure your caret is not &ldquo;touching&rdquo; a word and that there is no active selection when invoking the find-family command.
Aside:  This auto-copy feature can be exploited to get multi-line data into the <strong>Find what</strong> edit box, impossible by merely typing into the box.  Simply select the multi-line text that you want to search for, and then call up the Find dialog via one of its functions.  The selected text will appear as usual in the <strong>Find what</strong> box.  The line-ending character(s) won&rsquo;t be visible, but they will be there and will be matched when a search/replace action is initiated.</p>

<p>A valid <strong>Find what</strong> edit box entry length ranges from 1 to 2046 characters.  A valid <strong>Replace with</strong> edit box entry length ranges from 0 to 2046 characters.  Any text entered/pasted into these boxes beyond the 2046th character is simply ignored when an action is invoked.  Note that a replacement operation with a zero-length <strong>Replace with</strong> box entry is effectively a deletion of the matched text.</p>

<p>Selecting <strong>Search Mode</strong> of <strong>Regular expression</strong> will cause the <strong>Match whole word only</strong> option to become unchecked and disabled (greyed out).  A possible workaround to allow doing this type of searches is to add <code>\b</code> to the beginning and end of your regular expression <strong>Find what</strong> text.</p>

<p>The <strong>Find what</strong> and <strong>Replace with</strong> edit boxes have a dropdown arrow which allows the user to repeat searches conducted previously.  For a given run of Notepad++, the search history can grow rather large; when Notepad++ is exited, it only saves the last 10 items in the history by default; number of search/replace terms retained may be changed by editing the <code>config.xml</code> configuration file, per <a href="../preferences/index.html#preferences-for-advanced-users">Preferences for Advanced Users</a>.  The <strong>Find in Files</strong> tab&rsquo;s <strong>Filters</strong> and <strong>Directory</strong> text boxes have this &ldquo;history&rdquo; feature as well.  This history can be activated by clicking on the down-arrow with the mouse (or, equivalently, pressing <code>Alt+down</code>) to &ldquo;drop down&rdquo; the box, or directly (without dropping) by using the <code>down</code> (and/or <code>up</code>) keys &ndash; be careful though, sometimes when editing a control with the history feature, a user will accidentally hit an <code>up</code> or <code>down</code> arrow key when they really mean to press <code>left</code> or <code>right</code> arrow; this unfortunately wipes out the search/replace expression (as those are edited most often) that was being worked on and replaces it with some different text from the history buffer.  Unwanted items in the histories may be removed by dropping-down the box, highlighting the item to be removed, and pressing the <code>Delete</code> key.</p>

<p>The <strong>In selection</strong> option will automatically be chosen by Notepad++ if a Find dialog window is opened when more than 1024 characters occur in the active selection.  The selected text will also be placed in the <strong>Find what</strong> box.  Running a <strong>Count</strong> or <strong>Replace All</strong> action without making other changes to the search parameters will result in <em>Count: 1 match</em> or <em>Replace All: 1 occurrence was replaced</em>, respectively, which is likely not what was intended.  The proper resolution for this situation is to change the <strong>Find what</strong> text if the intention is to search within-selection, or deselect <strong>In selection</strong> if the intention is to search for a fairly long block of text.</p>

<p>The status bar area of the Find dialog keeps the user informed of what occurred during an action.  For example, it might say <em>Mark: 1 match</em> or <em>Find: Invalid regular expression</em>.  Colors are used in the status bar for emphasis:  red for some sort of error; green or blue for various success or general information.</p>

<p><strong>Important remark</strong>: When the regular expression search mode is invoked, the red alert error message &ldquo;Find: Invalid regular expression&rdquo; appears <strong>ONLY</strong> when you hit the <strong>Find Next</strong> button. All other possible actions lead to simply notify you that no result occurs, whereas, in fact, your search regular expression is just malformed. So, always do a <strong>Find Next</strong> search first, to test the validity of your regular expression input.</p>

<p>Notepad++ uses a flashing of the Find dialog window and the main Notepad++ window itself (when the Find dialog is not open) to indicate that search text has not been found (or possibly that a <strong>Wrap around</strong> in the search has occurred).  In general, if a search results in no matches, and the Find dialog window is open, that window will flash briefly as a failure indication.  If the Find dialog window is NOT open, and a failed search is initiated (e.g. via <strong>Find Next</strong> on the <strong>Search</strong> menu), the main Notepad++ window will flash briefly, again, as an indicator of the lack of success.  With the Find dialog window closed, but with <strong>Wrap around</strong> previously activated, a search that causes a wrap at an end of the file to occur will also cause the Notepad++ main window to flash.  In addition, audible feedback will be provided if a <strong>Find Next</strong> or <strong>Replace</strong> action results in the <strong>Find what</strong> text not being encountered; the sound can be muted using the <strong>Mute all sounds</strong> option in <a href="../preferences/index.html#misc"><strong>Settings &gt; Preferences &gt; MISC.</strong></a>.</p>

<p>If a search action is invoked by keyboard command with the Find dialog window open and input focus in the editing window, an unsuccessful search will result in input focus being changed to the Find window.</p>

<p><em>Disclaimer:</em>  It is Notepad++&rsquo;s design intention to fulfill some basic searching/replacing capability.  As such, Notepad++ searching is not infinitely flexible and capable of meeting all needs.  For such power needs, please turn to external tools, some of which integrate well with Notepad++.  Integrating well means that after such tools produce results, they can tell Notepad++ which files to open and which line and column numbers to move the caret to, in order to work with matched results.  Examples of such power file/text searching tools might be:  &ldquo;GrepWin&rdquo;, &ldquo;PowerGREP&rdquo;, &ldquo;FileSeek&rdquo;, &ldquo;Everything&rdquo; and many others.</p>

<h3 id="find-in-files-tab">Find in Files tab</h3>

<p>Find in Files allows both finding and replacing. You can choose an extension filter (<strong>Filters:</strong>), the containing folder (<strong>Directory:</strong>), and whether to also process hidden files or subfolders.</p>

<p>The <strong>Filters</strong> list is a space-separated list of wildcard expressions that cmd.exe can understand, like <code>*.doc foo.*</code>.</p>

<ul>
<li>Wildcards can include <code>*</code> for zero or more of any character, and <code>?</code> for exactly one of any character.</li>
<li>Most characters work as literals.  However, space is used as the separator, and thus cannot be used as a literal in your filter.  Some punctuation characters have special meanings (like the <code>?</code> and <code>*</code> wildcards, or the <code>!</code> exclusion or <code>!+\</code> for recursive exclusion), and cannot be used as literals.  Also, the <code>;</code> causes problems, so even though Microsoft <em>allows</em> it in file and path names, using a <code>;</code> in the <strong>Filters</strong> box will not work as you might hope.  If you want to match a space or a semicolon <code>;</code> or other problematic-punctuation in your file or folder for your <strong>Filter</strong> (whether for inclusion or exclusion), then use the <code>*</code> and/or <code>?</code> wildcards instead.  (So <code>x?y.txt</code> will match the file <code>x;y.txt</code> or <code>x y.txt</code> (with a space between <code>x</code> and <code>y</code>).)  And sorry, no, you cannot use quotes around a path-with-spaces to allow the spaces to work as literals: the space is a separator in this field.</li>
<li>If you have a blank filter, it is implied to be <code>*.*</code>.</li>
<li>You can also exclude certain file patterns by prefixing the filter with a <code>!</code>;
for example, <strong>Filters:  <code>!*.bin *.*</code></strong> will exclude files matching <code>*.bin</code> from the search results, but include any other filename.</li>

<li><p>As of Notepad++ v8.2, you can also exclude particular folders from the search: The exclusion operator is always <code>!</code> at the beginning of the expression, so in order to distinguish folder from file, <code>\</code> should be used as prefix of the folder name/pattern, following <code>!</code>. That allows the exclusion of the directories under the root directory you want to search (the 1st level of matched directories).
If users need to exclude folders with the same name (or names matching the specific pattern) in all levels, the <code>+</code> should be put between <code>!</code> and <code>\</code> to exclude them recursively. For example:</p>

<ul>
<li><code>!\tests</code> will not search any files in the <code>tests</code> folder,</li>
<li><code>!\bin*</code> will not search any files in the <code>bin</code> folder or <code>bin64</code> folder (or any other directory that matches <code>bin*</code>),</li>
<li><code>!+\log*</code> will <em>recursively</em> not search any files in folders that start with log (so directories like <code>.\log</code>, <code>.\logs</code>, <code>.\other\logfiles</code>, <code>.\many\layers\deep\log</code> will all be excluded from the search).</li>
</ul>

<p><em>Note</em>: There is no opposite (&ldquo;inclusive&rdquo;) version of the folder-exclusion syntax.  This means that other than checking <strong>☐ In all sub-folders</strong>, you cannot include specific folders in the search.  In particular, you cannot include specific subfolders of excluded folders (<code>!\skip \skip\exceptThis</code> will <em>not</em> work to skip the <code>\skip</code> subfolder but to still search the <code>\skip\exceptThis</code> subfolder).</p></li>

<li><p>As of Notepad++ v8.2, if you hover your mouse cursor over the <strong>Filters</strong> label, a helpful popup will show example syntax to you.</p></li>

<li><p>Please also note that the PathMatchSpec() Windows API is being used for the <strong>Filters</strong>, as its behavior departs from cmd.exe wildcard parsing sometimes.
To find only files that have no extension, you cannot just say <code>*.</code> despite this filter working in a Windows command prompt.  Instead, you can search for any file that <em>doesn&rsquo;t</em> have at least one letter in the extension: <code>!*.?*</code>.</p></li>
</ul>

<p>The <strong>Directory</strong> is the containing folder for where to search.  It has three options that affect its behavior:</p>

<ul>
<li><strong>☐ Follow current doc</strong> ⇒ If checked, it will default to searching the folder that contains the current active document (this sets the <code>fifFolderFollowsDoc</code> in <code>config.xml</code>).</li>
<li><strong>☐ In all sub-folders</strong> ⇒ If checked, it will recursively search sub-folders of the given folder.</li>
<li><strong>☐ In hidden folders</strong> ⇒ If checked, it will search hidden sub-folders as well as normally-visible sub-folders.</li>
</ul>

<h3 id="find-in-projects-tab">Find in Projects tab</h3>

<p>Find in Projects allows both finding and replacing search items in <a href="../session/index.html">Project Panels</a>. The files used for these operations are specified by the following check marks:</p>

<ul>
<li><strong>☐ Project Panel 1</strong> ⇒ If checked, all files listed in Project Panel 1 will be included into the search/replace operation.</li>
<li><strong>☐ Project Panel 2</strong> ⇒ If checked, all files listed in Project Panel 2 will be included into the search/replace operation.</li>
<li><strong>☐ Project Panel 3</strong> ⇒ If checked, all files listed in Project Panel 3 will be included into the search/replace operation.</li>
</ul>

<p>Only Project Panels which are currently open can be searched. The checkmarks of Project Panels which are not currently open are grayed out.</p>

<p>The <strong>Filters</strong> list works the same way as described in the previous <strong>Find in Files</strong> section.</p>

<h3 id="mark-tab">Mark tab</h3>

<p>The Mark tab from the Find/Replace dialog will perform searches similar to the Find tab, in the current document or selection:</p>

<ul>
<li><p>When <strong>Bookmark line</strong> is checked, a bookmark is dropped on each line where an individual hit occurs.  In the case where an individual hit spans multiple lines, each line in the span will receive the bookmark.</p></li>

<li><p>Otherwise, the matched pattern is highlighted according to the <a href="../preferences/index.html#global-styles"><strong>Settings &gt; Style Configurator &gt; Global Styles &gt; Find Mark Style</strong></a> setting.</p></li>
</ul>

<p>In either case, the <strong>Mark All</strong> button will perform the marking.  Similar to <a href="#find-replace-tabs"><strong>Replace All</strong></a>, <strong>Mark All</strong> will search from the beginning of the document to the end if <strong>Wrap Around</strong> is checked; if <strong>Wrap Around</strong> is not checked, it will mark from the caret position to the end of the file (if <strong>Backward direction</strong> is not checked) or from the beginning of the file to the caret position (if <strong>Backward direction</strong> is checked).</p>

<p>To control whether highlighting or bookmarks accumulate over successive searches, use the <strong>Clear all marks</strong> button to remove marks, or check <strong>Purge for each search</strong> for this action to be performed automatically on each search.  When the <strong>Clear all marks</strong> button is pressed, any marked text will have the marking background coloring removed; additionally, any bookmarks previously set will be removed if the <strong>Bookmark line</strong> checkbox is checked.</p>

<p>Once some text in a document is marked, it may be copied to the clipboard by pressing the <strong>Copy Marked Text</strong> button.  This feature is also invocable from the Search menu, and in order to be used in a macro, the Search menu version of this copy command must be used.</p>

<p>Highlighting is also available in Incremental search, and the style setting is <a href="../preferences/index.html#global-styles"><strong>Settings &gt; Style Configurator &gt; Global Styles &gt; Incremental highlight all</strong></a> instead.</p>

<h4 id="bookmarks-vs-marks">Bookmarks vs Marks</h4>

<p>Bookmarks and Marks are two slightly different things, though the <strong>Mark</strong> tab can affect both.  A Mark will highlight the individual match(es) in the text; a Bookmark affects the whole line, and is usually displayed as a circle (<code>●</code>) in the margin (though <a href="../preferences/index.html#margins-border-edge"><strong>Settings &gt; Preferences &gt; Margin/Border/Edge</strong></a> has a <code>☐ Display bookmark</code> toggle that will influence whether Bookmarks have that circle indicator or not).</p>

<p>Bookmarks, whether visible or not, have a menu that can control and navigate Bookmarks.  This menu is accessible either via <strong>Search &gt; Bookmark</strong> or by right clicking in the Bookmark portion of the margin (between the line number and the text, if line numbers are displayed).  This menu has options to toggle the state of the current line&rsquo;s Bookmark, to navigate to the next or previous Bookmark, to clear all Bookmarks, to cut or copy Bookmarked lines, to paste over (replace) Bookmarked lines, to delete Bookmarked (or non-Bookmarked) lines, or to invert all the Bookmarks (so all lines with a Bookmark have the Bookmark removed, and all lines without a Bookmark have a Bookmark added).</p>

<h3 id="search-results-window">Search results window</h3>

<p>After running one or more <strong>Find All in &hellip;</strong> commands, a new <strong>Search results</strong> window appears, and within it is placed a <strong>Search results</strong> tab.  The <strong>Search results</strong> window may be opened and/or given input focus by using the menu command <strong>Search &gt; Search Results Window</strong> or the <code>F7</code> keyboard shortcut.  <em>Note:</em>  That menu command will seem to not do anything if there haven&rsquo;t been any <strong>Find All in &hellip;</strong> commands run since Notepad++ was opened.</p>

<p><em>Definition:</em>  <strong>Find All in &hellip;</strong> commands include:</p>

<table>
<thead>
<tr>
<th>*Which <strong>Find All in &hellip;</strong> command*</th>
<th><em>Find window owner tab</em></th>
</tr>
</thead>

<tbody>
<tr>
<td>Find All in All Opened Documents</td>
<td><strong>Find</strong></td>
</tr>

<tr>
<td>Find All in Current Document</td>
<td><strong>Find</strong></td>
</tr>

<tr>
<td>Find All</td>
<td><strong>Find in Files</strong></td>
</tr>

<tr>
<td>Find All</td>
<td><strong>Find in Projects</strong></td>
</tr>
</tbody>
</table>

<p>The <strong>Search results</strong> window by default appears docked at the bottom of the Notepad++ main window.  Like other such windows, it can be moved or even be a free-floating window.</p>

<p>From <strong>Find All in &hellip;</strong> searches, three types of sections are added to the <strong>Search results</strong> window.  First is a line describing what was searched for, how many total matches (known as &ldquo;hits&rdquo;) occurred (this is also shown in the title bar for the window, for the most recently-occurring search), and how many files had matches.  Second is a line that shows the filename with the matches and the count of matches for that file (this type will be repeated if the search found multiple files with matches).  Last comes the details about the matches found, including line number and the line contents with the matched text emphasized.  The default emphasis is red text on a yellow background, but this may be changed in the Style Configurator&rsquo;s &ldquo;Search result&rdquo; Language area.</p>

<p>When Notepad++ populates the <strong>Search results</strong> window, it does so using one line for each match found by the search.  Note that this can and often does end with the same source file line being repeated multiple times in the output.  An example of this would be if you are searching for &ldquo;the&rdquo; in the line of text that reads &ldquo;Now is the time for all good men to come to the aid of their country&rdquo;; the <strong>Search results</strong> window would list the line three times, twice with each word &ldquo;the&rdquo; called out in red text with a yellow background, and a third time with &ldquo;the&rdquo; in &ldquo;their&rdquo; similarly emphasized.
However, multiple findings of the same search term may be collapsed into one search result by checking the option <a href="../preferences/index.html#searching"><strong>Settings &gt; Preferences &gt; Searching &gt; ☐ Search Result window: show only one entry per found line</strong></a>.</p>

<p>When the <strong>Search results</strong> window has input focus, the currently active line has a different background color, much like how the main editor window does by default.  Unlike the main editor window, where the current-line background feature may be turned off, the <strong>Search results</strong> window always has a background highlight for its active line.</p>

<p>Use the up and down arrows to navigate within the <strong>Search results</strong> window when it has input focus.  Double-clicking with the mouse or hitting <code>ENTER</code> when input focus is on a specific match will move the editor window to that match and cause its text to be selected.</p>

<p>Other ways to navigate back to an editor window via the <strong>Search results</strong> window matches include the <strong>Search</strong> menu items <strong>Next Search Result</strong> (keyboard: <code>F4</code>) and <strong>Previous Search Result</strong> (keyboard: <code>Shift+F4</code>).  These can be invoked regardless of where input focus is in Notepad++.</p>

<p>The <code>Delete</code> key can be used to delete individual results, file matches or whole search matches in the <strong>Search results</strong> window, depending on which type of line is active when the key is pressed.  As the result history is hierarchical, that is, tree-like, pressing <code>Delete</code> when in a higher-level element of the tree removes that whole branch.  Thus:</p>

<table>
<thead>
<tr>
<th>*Pressing Delete when <strong>Search results</strong> active line starts with&hellip;*</th>
<th><em>What is removed</em></th>
</tr>
</thead>

<tbody>
<tr>
<td>the text: &ldquo;Search&rdquo;</td>
<td>that &ldquo;Search&rdquo; line, all pathname lines under it, and all &ldquo;Line&rdquo; lines under the pathname lines</td>
</tr>

<tr>
<td>a pathname</td>
<td>that pathname line and all &ldquo;Line&rdquo; lines under it</td>
</tr>

<tr>
<td>the text: &ldquo;Line&rdquo;</td>
<td>only that line</td>
</tr>
</tbody>
</table>

<p>Multiple searches are listed under separate headers, which are &ldquo;foldable&rdquo;, so you can hide or unhide results from previous searches.  When you run a new search, previous searches are folded closed.</p>

<p>If the source file lines are judged by Notepad++ to be too long when they are copied to be placed in the <strong>Search results</strong> window, they are truncated and <strong>&hellip;</strong> is added at the end.  In this case, matched text occurring in the line after the <strong>&hellip;</strong> position isn&rsquo;t emphasized.  However, using a method to return to the editor window (e.g. pressing <code>Enter</code>) results in the correct selection of matching text there.  The length limit is 1024 characters; this includes the match line number information and other formatting.</p>

<p>If a search is conducted such that a match which spans two or more lines occurs, only the contents of the first line of that match is copied into the <strong>Search results</strong> window.  However, using a method to return to the editor window (e.g. pressing <code>Enter</code>) results in the correct selection of multi-line matching text there.</p>

<h4 id="rightclick-commands-in-the-client-area-of-a-search-results-window-s-tab"><code>RightClick</code> commands in the client area of a <strong>Search results</strong> window&rsquo;s tab</h4>

<h5 id="copying-text-from-the-search-results-window">Copying text from the <strong>Search results</strong> window</h5>

<p>There are two ways to copy exact text from the <strong>Search results</strong> window:  Make sure input focus is in the <strong>Search results</strong> window by selecting some text and press <code>Ctrl+C</code>, or <code>RightClick</code> to invoke the context menu and select <strong>Copy</strong>.  These two copy mechanisms produce identical results.  Another choice is to use the context menu&rsquo;s <strong>Copy Selected Line(s)</strong> command; this copies entire lines from the results, excluding search information (called &ldquo;metadata&rdquo;).</p>

<p>More precisely:</p>

<table>
<thead>
<tr>
<th><code>RightClick</code> item</th>
<th>What gets copied when <strong><code>RightClick</code> &gt; Copy Selected Line(s)</strong> is run</th>
</tr>
</thead>

<tbody>
<tr>
<td>a line with line # info</td>
<td>the entire line of the <code>RightClick</code> but without line number text</td>
</tr>

<tr>
<td>a pathname header line</td>
<td>all the lines for that single file without pathname or line number text</td>
</tr>

<tr>
<td>a &ldquo;search&rdquo; header line</td>
<td>all the lines for that search (1 or more files) without search header, pathname or line number text</td>
</tr>
</tbody>
</table>

<p><em>Tip</em>:  It is possible to select and copy a rectangular selection of data from the <strong>Search results</strong> window.  This is done using the usual <code>Shift+Alt+arrow keys</code> or by holding <code>Alt+LeftClick</code> and dragging with the mouse.  This is really only practical when using the <code>Ctrl+C</code> method of copying; <strong><code>RightClick</code> &gt; Copy Selected Line(s)</strong> doesn&rsquo;t work this way.</p>

<p>There is a capability to copy the list of files containing hits from past searches (v8.0.0 and later).  The <strong>Copy Pathname(s)</strong> context menu command copies to the clipboard the full pathnames of all files appearing in <strong>Search results</strong>.</p>

<h5 id="other-commands">Other commands</h5>

<p>The <strong>Search results</strong> window/tab accumulates results from every <strong>Find All in &hellip;</strong> search the user does; the results from old searches remain until the user removes them.  Individual results can be deleted with the <code>Delete</code> key, or all previous results can be deleted by invoking <strong>Clear all</strong>.  Stale results can be removed to reduce visual clutter, or when it is desired that a follow-on action should not be affected by old results.  An example of this would be the <strong>Open all</strong> command which opens <em>all</em> files listed in the <strong>Search results</strong> tab that have previously had hits.  If the search history in <strong>Search results</strong> is really long, it may not be desirable to open all files listed there, so using <strong>Clear all</strong> before doing some new searches with the intent to <strong>Open all</strong> afterwards may be the thing to do.</p>

<p>The <strong>Select all</strong> command is self-explanatory:  All text in the <strong>Search results</strong> tab is selected.</p>

<p>The contents of the <strong>Search results</strong> tab are in the form of a tree.  When Notepad++ adds to the result history, the user can see all of the information from the recently-added search.  However, before adding new results, Notepad++ will fold all previous result data.</p>

<p>The user can fold/unfold &ldquo;branches&rdquo; of this tree.  To fold, click with the mouse on the little box symbol with an interior <code>-</code>, found to the left of each line.  After doing so, that part of the tree will be folded (removed from view) and the first line of the branch (remaining visible) will then show a <code>+</code> in the box symbol.  To unfold an individual item that has previously been folded (either by the user or by Notepad++&rsquo;s automatic mechanism), simply click the box symbol with the <code>+</code>.  That branch will then be expanded and shown again.</p>

<p>The <strong>Fold all</strong> and <strong>Unfold all</strong> commands perform the corresponding actions on all elements of the entire result history in the <strong>Search results</strong> window at once. (These were called <strong>Collapse all</strong> and <strong>Uncollapse all</strong> before v8.4.6.)</p>

<h5 id="searching-in-previously-found-results-secondary-searching">Searching in previously-found results (secondary searching)</h5>

<p>Assume that you have done a search and your results are in a tab in the <strong>Search results</strong> window.  Now you&rsquo;d like to conduct a search but with a scope of only the files that have previous matches.  Or maybe you want to look only in the <em>lines</em> matched by previous searches, not only the matched files, tightening the search criteria even more.  Can you do this sort of second-level searching with Notepad++?  Yes, by <code>RightClick</code>ing the <strong>Search results</strong> window client area and selecting <strong>Find in these search results&hellip;</strong>.</p>

<p>Selecting <strong>Find in these search results&hellip;</strong> will cause a window to pop up, which looks much like the standard <strong>Find</strong> window, but stripped down a bit.  Once you input your search parameters and choose <strong>Find All</strong>, a <em>new</em> <strong>Search results</strong> tab will open (in the <strong>Search results</strong> window) with the results of the &ldquo;refined&rdquo; search.</p>

<p>The popup window has a parameter not available in the searches described earlier:  <strong>☐ Search only in found lines</strong>.  Checking this box limits the search to lines that appear in matched files in the parent <strong>Search results</strong> window.  Unchecking the box will cause the new search to examine previously matched files in their entirety.  When a search has been limited to previously-found lines, its results will indicate this by using this type of output:  <code>Search &quot;___&quot; (__ hits in __ files - Line Filter Mode: only display the filtered results)</code> as opposed to the normally seen:  <code>Search &quot;___&quot; (__ hits in __ files)</code></p>

<p><em>Tip:</em>  Use the <code>RightClick</code> option <strong>Clear all</strong> to limit the scope of these types of searches (before invoking the secondary search!) &ndash; remember: a <strong>Find in these search results&hellip;</strong> search will look in files matched by <em>all</em> previous searches whose results are still present in the parent <strong>Search results</strong> tab.</p>

<p><em>Tip:</em>  Since the newly opened <strong>Search results</strong> window also has a <code>RightClick</code> menu, you may do another <strong>Find in these search results&hellip;</strong> based upon the new results, focusing your search for some bit of data even more.  This type of refinement may be repeated as often as desired.  [Note that the title bar of the window does <em>not</em> show the hit count of the currently active tab, but rather shows the hit count of the <em>first</em> <strong>Search results</strong> tab of the window.]</p>

<p><em>Note:</em>  The commands that switch input focus to the <strong>Search results</strong> window always activate the <em>first</em> <strong>Search results</strong> tab, not any additional <strong>Search results</strong> tabs that may have been created.</p>

<p><em>Note:</em>  The contents of the <strong>Search results</strong> window are discarded upon Notepad++ shutdown.  If it contains data of importance, it should be copied using one of the methods above, and saved in a more-permanent location.</p>

<h5 id="search-results-configuration-options">Search results configuration options</h5>

<p>There are currently two ways to configure the <strong>Search results</strong> window behavior, both located in the <code>RightClick</code> context menu:</p>

<ul>
<li><strong>Word wrap long lines</strong></li>
<li><strong>Purge for every search</strong></li>
</ul>

<p>When <strong>Word wrap long lines</strong> is turned on (checked), the <strong>Search results</strong> window text wraps at the right edge, and is continued on the next visible line.  With the feature off, the window has a horizontal scrollbar, so that the rightmost text on long lines may be scrolled into the user&rsquo;s view.</p>

<p>To some users older search results accumulating are an annoyance, so Notepad++ supports a setting that, after turned on, removes any old search results from the window before populating it with new ones.  To set or clear this setting, right-click anywhere in the Search results window, then click on the <strong>Purge for every search</strong> entry to change that setting: There will be a checkmark to indicate it&rsquo;s already on, and no checkmark to indicate it&rsquo;s off.
<em>Note</em>: Clicking this option doesn&rsquo;t immediately purge the old results; instead, searches made subsequent to enabling this option will purge the old results.</p>

<h2 id="dialog-free-search-mark-actions">Dialog-free search/mark actions</h2>

<h3 id="searching">Searching</h3>

<p>The following commands, available through the Search menu or keyboard shortcuts, perform a search without invoking a dialog (with the default shortcuts):</p>

<ul>
<li><strong>Find Next (<code>F3</code>)/ Find Previous (<code>Shift+F3</code>)</strong>: Repeat searching the current search target, either down or up.

<ul>
<li>The &ldquo;current search target&rdquo; is whatever <em>Find what</em> string was most-recently active from either the Find/Replace dialog or from the <strong>Select and Find Next / Select and Find Previous</strong> commands.</li>
</ul></li>
<li><strong>Select and Find Next (<code>Ctrl+F3</code>) / Select and Find Previous (<code>Ctrl+Shift+F3</code>)</strong>: Search for the word the caret is in, or the selected text, down or up. The searched word or selection is stored in the find history, and the search can be repeated with <strong>Find Next / Find Previous</strong>.

<ul>
<li>The specific search behavior:

<ul>
<li>copies the selected text to <strong>Find what</strong> box of <strong>Find</strong> window for future use, then uses that same string for this specific search

<ul>
<li>if there is no selection and the caret is just at a single character position, it uses the word that the caret position is a part of (if any)</li>
<li>if the caret is in whitespace with no selection active, it will not perform a search, and the caret will remain where it was</li>
</ul></li>
<li>uses the following set of options:

<ul>
<li>uses <strong>☐ Match case</strong> setting from <strong>Find</strong> window</li>
<li>uses <strong>☐ Match whole word only</strong> setting from <strong>Find</strong> window</li>
<li>uses <strong>☐ Wrap around</strong> setting from <strong>Find</strong> window</li>
<li>uses <strong>Search mode = Normal</strong> (regardless of its current setting in the <strong>Find</strong> window)</li>
</ul></li>
<li>(all mentions of the <strong>Find</strong> window in this search description are still true even if the <strong>Find</strong> window is not currently visible)</li>
</ul></li>
</ul></li>
<li><strong>Find (Volatile) Next (<code>Ctrl+Alt+F3</code>) / Find (Volatile) Previous (<code>Ctrl+Alt+Shift+F3</code>)</strong>: Search for the word the caret is in, or the selected text, down or up.

<ul>
<li>The searched word or selection is not stored in the find history, and the search will not be repeatable with <strong>Find Next / Find Previous</strong>. (&ldquo;Volatile&rdquo; here means &ldquo;not stored&rdquo;.)  However, because it will have moved the caret and selection to the next match, repeated <strong>Find (Volatile) Next / Find (Volatile) Previous</strong> works as expected.</li>
<li>The specific search behavior:

<ul>
<li>uses the selected text as the search text, but does <strong>not</strong> overwrite the existing <strong>Find what</strong> value in the <strong>Find</strong> dialog

<ul>
<li>if there is no selection and the caret is just at a single character position, it uses the word that the caret position is a part of (if any)</li>
<li>if the caret is in whitespace with no selection active, it will not perform a search, and the caret will remain where it was</li>
</ul></li>
<li>uses the least-strict set of options, providing the most flexibility in the results provided by a volatile search:

<ul>
<li>considers <strong>☐ Match case</strong> to be unchecked</li>
<li>considers <strong>☐ Match whole word only</strong> to be unchecked</li>
<li>considers <strong>☐ Wrap around</strong> to be checked</li>
<li>considers <strong>Search mode</strong> to be <strong>Normal</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h4 id="comparison-between-select-and-find-next-and-find-volatile-next"><em>Comparison between &ldquo;Select and Find Next&rdquo; and &ldquo;Find (Volatile) Next&rdquo;</em></h4>

<p>Both commands <strong>Select and Find Next</strong> and <strong>Find (Volatile) Next</strong> search based on the active selection or caret position. However, <strong>Select and Find Next</strong> stores the searched word so it&rsquo;s available to a subsequent <strong>Find Next</strong> action and to the <strong>Find</strong> dialog&rsquo;s <strong>Find what</strong> field, whereas <strong>Find (Volatile) Next</strong> does not store the search word for those uses.  Example sequence:</p>

<ul>
<li><p>If you do <strong>Select and Find Next</strong> command with <code>word1</code> selected, then you can later use the normal <strong>Find Next</strong> command to search for <code>word1</code>, even if you have moved your caret or selection elsewhere to <code>word2</code>.  Further, if no new text has been selected, the <strong>Find</strong> and related dialogs will show <strong>Find what</strong> to be the active search value. (<em>Note</em>: See the section on <a href="../preferences/index.html#searching"><strong>Settings &gt; Preferences &gt; Searching</strong></a>, because those options can cause other text to overwrite the <strong>Find what</strong> field independently from the <strong>Select and Find Next</strong> action, making it appear that the search string wasn&rsquo;t stored.)</p></li>

<li><p>If your caret is on word <code>word2</code>, <strong>Find (Volatile) Next</strong> will search for the next occurrence of <code>word2</code>. Now if you move your caret onto <code>word3</code> and do <strong>Find (Volatile) Next</strong>, it will search for the next <code>word3</code>, and <code>word2</code> is forgotten.  This will <em>not</em> override the &ldquo;remembered&rdquo; search, so running <strong>Find Next</strong> will still be looking for the old <code>word1</code> from the previous <strong>Select and Find Next</strong>, rather than <code>word2</code> or <code>word3</code> from the <strong>Find (Volatile) Next</strong> searches.</p></li>
</ul>

<h3 id="marking-with-a-color-style-and-highlighting">Marking with a color/style and Highlighting</h3>

<p>Use the <strong>Style All Occurrences of Token</strong> or <strong>Clear Style</strong> submenus of the Search menu (previously called the <strong>Mark All</strong> or <strong>Unmark All</strong> submenus) to mark or unmark all occurrences of the selected text or word the caret is in (the &ldquo;Token&rdquo;) if there is no active selection.  You have a choice of five different colors/styles (numbered 1 through 5) in which to mark text in this manner.  The <strong>Style One Token</strong> (previously, <strong>Mark One</strong>) submenu options work similarly, but only on the single occurrence of selected text or caret word.</p>

<p>The settings for each of the 5 available colors/styles are <a href="../preferences/index.html#global-styles"><strong>Settings &gt; Style Configurator &gt; Global Styles &gt; Mark style #</strong></a>.</p>

<p>If you&rsquo;ve highlighted some groups of text in this manner, and you wish to copy those sections, the <strong>Copy Styled Text</strong> submenu of the Search menu will allow you to do that.  Quick search for previously marked text is possible via the <strong>Jump Up</strong> or <strong>Jump Down</strong> submenu choices.</p>

<p>Note: In older versions of Notepad++, the <strong>Mark All</strong> submenu name can cause some confusion between an identically-named action button in the Mark tab of the Find family dialog.  The two types of &ldquo;marking&rdquo; are different but do share some features.  For example, the Copy Styled Text submenu commands will allow you to copy text that has been styled with number 1 through 5 styling OR text that has been marked using the Mark tab of Find.  This has been improved by renaming the menu to <strong>Style All Occurrences of Token</strong>.</p>

<p>You can also cause all occurrences of the word at the caret to get dynamically highlighted if you activate Smart Highlighting; the mark style then is <a href="../preferences/index.html#global-styles"><strong>Settings &gt; Style Configurator &gt; Global Styles &gt; Smart Highlighting</strong></a>. You may choose there whether the matching should be sensitive to case.</p>

<p>You activate smart highlighting through <a href="../preferences/index.html#highlighting"><strong>Settings &gt; Preferences &gt; Highlighting &gt; Smart highlighting &gt; Enable</strong></a>.  You can change whether or not the smart highlighting is case sensitive or requires whole words using other options in that preferences dialog.</p>

<h3 id="manipulating-bookmarks">Manipulating Bookmarks</h3>

<p>The <strong>Search &gt; Bookmark</strong> menu allows you to navigate and manipulate Bookmarks and Bookmarked lines (see <a href="#bookmarks-vs-marks">&ldquo;Bookmarks vs Marks&rdquo;</a> for more on the Bookmark feature).</p>

<ul>
<li><strong>Toggle Bookmark</strong> - Toggle the state of the Bookmark indicator on the active line.</li>
<li><strong>Next Bookmark</strong> - Navigate to the next Bookmark in the active document.</li>
<li><strong>Previous Bookmark</strong> - Navigate to the previous Bookmark in the active document.</li>
<li><strong>Clear all Bookmarks</strong> - Remove all Bookmark indicators in the active document.</li>
<li><strong>Cut Bookmarked Lines</strong> - Place all Bookmarked lines in the Clipboard and remove those lines from the active document.</li>
<li><strong>Copy Bookmarked Lines</strong> - Place all Bookmarked lines in the Clipboard but leave those lines in the active document.</li>
<li><strong>Paste to (Replace) Bookmarked Lines</strong> - Paste the contents of the Clipboard to replace the contents of all Bookmarked lines.  (Thus, if your Clipboard is <code>Hello World</code>, then <em>every</em> Bookmarked line will say <code>Hello World</code> after this action.)</li>
<li><strong>Remove Bookmarked Lines</strong> - Remove all Bookmarked lines from the active document.</li>
<li><strong>Remove Non-Bookmarked Lines</strong> - Remove all lines that are not Bookmarked from the active document, leaving only the Bookmarked lines.</li>
<li><strong>Inverse Bookmark</strong> - Every line that was Bookmarked is now not Bookmarked, and every line that was previously not Bookmarked is now Bookmarked.  (Equivalent to choosing <strong>Toggle Bookmark</strong> once on every line in the active document.)</li>
</ul>

<p>These actions are also available by right-clicking on the Bookmark margin.</p>

<h3 id="change-history">Change History</h3>

<p>The <strong>Search &gt; Change History</strong> menu allows you to easily navigate between the lines shown as changed by the Change History Margin (see <a href="../preferences/index.html#margins-border-edge"><strong>Settings &gt; Preferences &gt; Margins/Border/Edge &gt; Change History</strong></a>).  (This menu was added in v8.5.5.)</p>

<ul>
<li><strong>Go to Next Change</strong> - Move to the next line that is indicated as being changed.</li>
<li><strong>Go to Previous Change</strong> - Move to the previous line that is indicated as being changed.</li>
<li><strong>Clear Change History</strong> - Removes the active change history, so the Change History Margin appears blank, as it did when you first loaded the document.</li>
</ul>

<h2 id="finding-characters-in-a-specific-range">Finding characters in a specific range</h2>

<p>It is sometimes desirable to search for characters by their codepoint (underlying numerical value), and even to search for text that matches a range of character codepoints (like finding all characters from <code>a</code> to <code>z</code>).
Notepad++ provides a dialog for doing this character-range search, available using the <strong>Search &gt; Find characters in range&hellip;</strong> action.</p>

<p>A custom range of characters can be asked for, as well as either half of the 0..255 range: ASCII covers the lower half, non-ASCII covers the upper part. Note that entries should be in decimal notation, and that values above 255 are not handled in a useful way (so fancy Unicode characters cannot be searched for in this manner).</p>

<p>This search may proceed up or down, and optionally wraps around. Hit <strong>Find</strong> to run this range-search, and hit <strong>Close</strong> to leave the dialog.</p>

<p>The <a href="#regular-expressions">regular expressions</a> search mode (described <a href="#regular-expressions">below</a>) also provides a way to specify a range (or multiple ranges) of characters using a <a href="#character-classes">character class</a>, but that mode can be difficult for inexperienced users, so this dialog has been provided as an easier alternative.</p>

<h2 id="incremental-search">Incremental Search</h2>

<p>Incremental search is similar to the searching capabilities found in your favorite web browser (like Firefox or Chrome).  You can launch it from the <strong>Search &gt; Incremental Search</strong> menu, or the keyboard shortcut (Ctrl+Alt+I).</p>

<p>This command will show a small region at the bottom of the Notepad++, which has a few simple features.</p>

<ul>
<li>The <strong>X</strong> allows you to close out of Incremental Search.</li>
<li>The <strong>Find</strong> box is where you type your literal search term.</li>
<li>The <strong>&lt;</strong> and <strong>&gt;</strong> buttons navigate backward and forward through the search results (wrapping around when it reaches the end or start of the document).</li>
<li>If the <strong>☐ Highlight all</strong> checkbox is not checked, it will only highlight the current match; if it is checked, all matches will be highlighted.</li>
<li>If the <strong>☐ Match case</strong> checkbox is checked, the results will only match if case is exactly the same, otherwise case doesn&rsquo;t matter.</li>
<li>To the right of those checkboxes, a message about the results will occur: either the number of matches, a message that indicates that you&rsquo;ve wrapped around to the top or bottom of the document, or &ldquo;Phrase not found&rdquo; if there are no matches.  When there are no matches, the <strong>Find</strong> box also changes color.</li>
</ul>

<h2 id="extended-search-mode">Extended Search Mode</h2>

<p>In extended mode, these escape sequences (a backslash followed by a single character and optional material) have special meaning, and will not be interpreted literally.</p>

<ul>
<li><code>\n</code>:  The Line Feed control character LF (ASCII 0x0A)</li>
<li><code>\r</code>:  The Carriage Return control character CR (ASCII 0x0D)</li>
<li><code>\t</code>:  The TAB control character (ASCII 0x09)</li>
<li><code>\0</code>:  The NUL control character (ASCII 0x00) †</li>
<li><code>\\</code>:  The literal backslash character (ASCII 0x5C)</li>
<li><code>\b</code>:  The binary representation of a byte, made of 8 digits which are either 1&rsquo;s or 0&rsquo;s. †

<ul>
<li><code>\b00100000</code> will match the SPACE character (ASCII 32 is &ldquo;00100000&rdquo; in 8-bit binary)</li>
</ul></li>
<li><code>\o</code>:  The octal representation of a byte, made of 3 digits in the 0-7 range. †

<ul>
<li><code>\o040</code> will match the SPACE character (ASCII 32 is &ldquo;040&rdquo; in 3-digit octal)</li>
</ul></li>
<li><code>\d</code>:  The decimal representation of a byte, made of 3 digits in the 0-9 range. †

<ul>
<li><code>\d032</code> will match the SPACE character (ASCII 32 is &ldquo;032&rdquo; in 3-digit decimal)</li>
</ul></li>
<li><code>\x</code>:  The hexadecimal representation of a byte, made of 2 digits in the 0-9, A-F/a-f range.

<ul>
<li><code>\x20</code> will match the SPACE character (ASCII 32 is &ldquo;20&rdquo; in 2-digit hexadecimal)</li>
</ul></li>
<li><code>\u</code>:  The hexadecimal representation of a two-byte character, made of 4 digits in the 0-9, A-F/a-f range. †

<ul>
<li>In Unicode builds, finds a Unicode character: for example, <code>\u263A</code> matches the <code>☺</code> char, in an UTF-8 encoded file.</li>
<li>In ANSI builds, finds characters requiring two bytes, like in the Shift-JIS encoding.</li>
</ul></li>
</ul>

<p>† NOTE: While some of these Extended Search Mode escape sequences look like regular expression escape sequences, they are not identical.  Ones marked with † are different from or not available in regular expressions.</p>

<h2 id="regular-expressions">Regular Expressions</h2>

<p>Notepad++ regular expressions (&ldquo;regex&rdquo;) use the Boost regular expression library v1.80 (as of NPP v8.4.7), which is based on PCRE (Perl Compatible Regular Expression) syntax, only departing from it in very minor ways. Complete documentation on the precise implementation is to be found on the Boost pages for <a href="https://www.boost.org/doc/libs/1_80_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html">search syntax</a> and <a href="https://www.boost.org/doc/libs/1_80_0/libs/regex/doc/html/boost_regex/format/boost_format_syntax.html">replacement syntax</a></p>

<p>The Notepad++ Community has a <a href="https://notepad-plus-plus.org/community/topic/15765/faq-desk-where-to-find-regex-documentation">FAQ on other resources for regular expressions</a>.</p>

<p>Note: Regular expression &ldquo;backward&rdquo; search is disallowed due to sometimes surprising results. If you really need this feature, please see <a href="../preferences/index.html#preferences-for-advanced-users"><strong>Allow regex backward search</strong></a> to learn how to activate this option.</p>

<p><strong>Important Note</strong>: Syntax that works in the <strong>Find What:</strong> box for searching will not always work in the <strong>Replace with:</strong> box for replacement.  There are different syntaxes.  The <a href="#control-characters">Control Characters</a> and <a href="#match-by-character-code">Match by character code</a> syntax work in both; other than that, see the individual sections for <a href="#regex-special-characters-for-searches">Searches</a> vs <a href="#substitutions">Substitutions</a> for which syntaxes are valid in which fields.</p>

<h3 id="regex-special-characters-for-searches">Regex Special Characters for Searches</h3>

<p>In a regular expression (shortened into regex throughout), special characters interpreted are:</p>

<h4 id="single-character-matches">Single-character matches</h4>

<ul>
<li><p><code>.</code> or <code>\C</code> ⇒ Matches any character. If you check the box which says <strong>. matches newline</strong>, the dot matches any character, including newline sequences (<code>\r</code> or <code>\n</code>).  With the option unchecked, <code>.</code> only matches characters within a line.</p></li>

<li><p><code>\X</code> ⇒ Matches a single non-combining character followed by any number (zero or more) combining characters. You can think of <code>\X</code> as a &ldquo;<code>.</code> on steroids&rdquo;: it matches the whole <a href="https://en.wikipedia.org/wiki/Grapheme" title="character with all its modifiers">grapheme</a> as a unit, not just the base character itself.  This is useful if you have a Unicode encoded text with accents as separate, combining characters.  For example, the letter <code>ǭ̳̚</code>, with four combining characters after the <code>o</code>, can be found either with the regex <code>(?-i)o\x{0304}\x{0328}\x{031a}\x{0333}</code> or with the shorter regex <code>\X</code> (the latter, being generic, matches more than just <code>ǭ̳̚</code>, inluding but not limited to <code>ą̳̄̚</code> or <code>o</code> alone); if you want to limit the <code>\X</code> in this example to just match a possibly-modified <code>o</code> (so &ldquo;<code>o</code> followed by 0 or more modifiers&rdquo;), use a lookahead before the <code>\X</code>: <code>(?=o)\X</code>, which would match <code>o</code> alone or <code>ǭ̳̚</code>, but not <code>ą̳̄̚</code>.</p></li>

<li><p><code>\$</code> , <code>\(</code> , <code>\)</code> , <code>\*</code> , <code>\+</code> , <code>\.</code> , <code>\?</code> , <code>\[</code> , <code>\]</code> , <code>\\</code> , <code>\|</code> ⇒ Prefixing a special character with <code>\</code> to &ldquo;escape&rdquo; the character allows you to search for a literal character when the regular expression syntax would otherwise have that character have a special meaning as a regex meta-character.</p>

<ul>
<li>The characters <code>$ ( ) * + . ? [ ] \ |</code> all have special meaning to the regex engine in normal circumstances; to get them to match as a literal (or to show up as a literal in the substitution), you will have to prefix them with the <code>\</code> character.</li>
<li>There are also other characters which are special only in certain circumstances (any time a character is used with a non-literal meaning throughout the Regular Expression section of this manual); if you want to match one of those sometimes-special characters as literal character <em>in those situations</em>, those sometimes-special characters will also have to be escaped <em>in those situations</em> by putting a <code>\</code> before it.</li>
<li><em>Please note</em>: if you escape a normal character, it will sometimes <em>gain</em> a special meaning; this is why so many of the syntax items listed in this section have a <code>\</code> before them.</li>
</ul></li>
</ul>

<h5 id="match-by-character-code">Match by character code</h5>

<p>It is possible to match any character using its character code.  This allows searching for any character, even if you cannot type it into the Find box, or the Find box doesn&rsquo;t seem to match your emoji that you want to search for.  If you are using an ANSI encoding in your document (that is, using a character set like Windows 1252), you can use any character code with a decimal codepoint from 0 to 255.  If you are using Unicode (one of the UTF-8 or UTF-16 encodings), you can actually match any Unicode character.  These notations require knowledge of hexadecimal or octal versions of the character code.  (You can find such character code information on most web pages about ASCII, or about your selected character set, and about UTF-8 and UTF-16 representations of Unicode characters.)</p>

<ul>
<li><p><code>\0ℕℕℕ</code> ⇒ A single byte character whose code in octal is ℕℕℕ, where each ℕ is an octal digit.  (That&rsquo;s the number <code>0</code>, not the letter <code>o</code> or <code>O</code>.)  This notation works for for codepoints 0-255 (<code>\0000</code> - <code>\0377</code>), which covers the full ANSI character set range, or the first 256 Unicode characters. For example, <code>\0101</code> looks for the letter <code>A</code>, as 101 in octal is 65 in decimal, and 65 is the character code for <code>A</code> in ASCII, in most of the character sets, and in Unicode.</p></li>

<li><p><code>\xℕℕ</code> ⇒ Specify a single character with code ℕℕ, where each ℕ is a hexadecimal digit. What this stands for depends on the text encoding. This notation works for codepoints 0-255 (<code>\x00</code> - <code>\xFF</code>), which covers the full ANSI character set range, or the first 256 Unicode characters.  For instance, <code>\xE9</code> may match an <code>é</code> or a <code>θ</code> depending on the character set (also known as the &ldquo;code page&rdquo;) in an ANSI encoded document.</p></li>
</ul>

<p>These next two only work with Unicode encodings (so the various UTF-8 and UTF-16 encodings):</p>

<ul>
<li><p><code>\x{ℕℕℕℕ}</code> ⇒ Like <code>\xℕℕ</code>, but matches a full 16-bit Unicode character, which is any codepoint from U+0000 to U+FFFF.</p></li>

<li><p><code>\x{ℕℕℕℕ}\x{ℕℕℕℕ}</code> ⇒ For Unicode characters above U+FFFF, in the range U+10000 to U+10FFFF, you need to break the single 5-digit or 6-digit hex value and encode it into two 4-digit hex codes; these two codes are the &ldquo;surrogate codes&rdquo; for the character.  For example, to search for the <code>🚂</code> STEAM LOCOMOTIVE character at U+1F682, you would search for the surrogate codes <code>\x{D83D}\x{DE82}</code>.</p>

<ul>
<li>If you want to know the surrogate codes for a given character, search the internet for &ldquo;surrogate codes for <em>character</em>&rdquo; (where <em>character</em> is the fancy Unicode character you need the codes for); the surrogate codes are equivalent to the two-word UTF-16 encoding for those higher characters, so UTF-16 tables will also work for looking this up.  Any site or tool that you are likely to be using to find the U+###### for a given Unicode character will probably already give you the surrogate codes or UTF-16 words for the same character; if not, find a tool or site that does.</li>
<li>You can also compute surrogate codes yourself from the character code, but only if you are comfortable with hexadecimal and binary.  Skip the following bullets if you are prone to mathematics-based PTSD.

<ul>
<li>Start with your Unicode U+######, calling the hexadecimal digits as <code>PPWXYZ</code>.</li>
<li>The <code>PP</code> digits indicate the plane.  subtract one and convert to the 4 binary bits <code>pppp</code> (so <code>PP</code>=<code>01</code> becomes <code>0000</code>, <code>PP</code>=<code>0F</code> becomes <code>1110</code>, and <code>PP</code>=<code>10</code> becomes <code>1111</code>)</li>
<li>Convert each of the other digits into 4 bits (<code>W</code> as <code>wwww</code>, <code>X</code> as <code>xxvv</code>, <code>Y</code> as <code>yyyy</code>, and <code>Z</code> as <code>zzzz</code>; you will see in a moment why two different characters are used in <code>xxvv</code>)</li>
<li>Write those 20 bits in sequence: <code>ppppwwwwxxvvyyyyzzzz</code></li>
<li>Group into two equal groups: <code>ppppwwwwxx</code> and <code>vvyyyyzzzz</code> (you can see that the <code>X</code> ⇒ <code>xxvv</code> was split between the two groups, hence the notation)</li>
<li>Before the first group, insert the binary digits <code>110110</code> to get <code>110110ppppwwwwxx</code>, and split into the nibbles <code>1101 10pp ppww wwxx</code>.  Convert those nibbles to hex: it will give you a value from <code>\x{D800}</code> thru <code>\x{DBFF}</code>; this is the High Surrogate code</li>
<li>Before the second group, insert the binary digits <code>110111</code> to get <code>110111vvyyyyzzzz</code>, and split into the nibbles <code>1101 11vv yyyy zzzz</code>.  Convert those nibbles to hex: it will give you a value from <code>\x{DC00}</code> thru <code>\x{DFFF}</code>; this is the Low Surrogate code</li>
<li>Combine those into the final <code>\x{ℕℕℕℕ}\x{ℕℕℕℕ}</code> for searching.</li>
</ul></li>
<li>For more on this, see the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)">Unicode Planes</a>, and the discussion in the Notepad++ Community Forum about how to <a href="https://community.notepad-plus-plus.org/post/66322">search for non-ASCII characters</a></li>
</ul></li>
</ul>

<h5 id="collating-sequences">Collating Sequences</h5>

<ul>
<li><code>[[.</code><em>col</em><code>.]]</code> ⇒ The character the <em>col</em> &ldquo;<a href="https://www.boost.org/doc/libs/1_70_0/libs/regex/doc/html/boost_regex/syntax/collating_names.html">collating sequence</a>&rdquo; stands for. For instance, in Spanish, <code>ch</code> is a single letter, though it is written using two characters. That letter would be represented as <code>[[.ch.]]</code>. This trick also works with symbolic names of control characters, like <code>[[.BEL.]]</code> for the character of code 0x07. See also the discussion on character ranges.</li>
</ul>

<h5 id="control-characters">Control characters</h5>

<ul>
<li><p><code>\a</code> ⇒ The BEL control character 0x07 (alarm).</p></li>

<li><p><code>\b</code> ⇒ The BS control character 0x08 (backspace). This is only allowed inside a character class definition. Otherwise, this means &ldquo;a word boundary&rdquo;.</p></li>

<li><p><code>\e</code> ⇒ The ESC control character 0x1B.</p></li>

<li><p><code>\f</code> ⇒ The FF control character 0x0C (form feed).</p></li>

<li><p><code>\n</code> ⇒ The LF control character 0x0A (line feed). This is the regular end of line under Unix systems.</p></li>

<li><p><code>\r</code> ⇒ The CR control character 0x0D (carriage return). This is part of the DOS/Windows end of line sequence CR-LF, and was the EOL character on Mac 9 and earlier. OSX and later versions use <code>\n</code>.</p></li>

<li><p><code>\t</code> ⇒ The TAB control character 0x09 (tab, or hard tab, horizontal tab).</p></li>

<li><p><code>\c☒</code> ⇒ The control character obtained from character ☒ by stripping all but its 5 lowest order bits. For instance, <code>\c1</code>, <code>\cA</code> and <code>\ca</code> all stand for the SOH control character 0x01.  You can think of this as &ldquo;\c means ctrl&rdquo;, so <code>\cA</code> is the character you would get from hitting Ctrl+A in a terminal.  (Note that <code>\c☒</code> may not work if <code>☒</code> is outside of the <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" title="BMP">Basic Multilingual Plane</a> &ndash; that is, it only works if <code>☒</code> is in the Unicode character range U+0000 - U+FFFF. The intention of <code>\c☒</code> is to mnemonically escape the ASCII control characters obtained by typing <code>Ctrl+☒</code>, it is expected that you will use a simple ASCII alphanumeric for the <code>☒</code>, like <code>\cA</code> or <code>\ca</code>.)</p></li>
</ul>

<h5 id="special-control-escapes">Special Control escapes</h5>

<ul>
<li><code>\R</code> ⇒ Any newline sequence.  Specifically, the atomic group <code>(?&gt;\r\n|\n|\x0B|\f|\r|\x85|\x{2028}|\x{2029})</code>.  Please note, this sequence might match one or two characters, depending on the text.  Because its length is variable-width, it cannot be used in lookbehinds.  Because it expands to a parentheses-based group with an alternation sequence, it cannot be used inside a character class.  If you accidentally attempt to put it in a character class, it will be interpreted like any other literal-character escape (where <code>\☒</code> is used to make sure that the next character is literal) meaning that the <code>R</code> will be taken as a literal <code>R</code>, without any special meaning.  For example, if you try <code>[\t\R]</code>: you may be intending to say, &ldquo;match any single character that&rsquo;s a tab or a newline&rdquo;, but what you are actually saying is &ldquo;match the tab or a literal R&rdquo;; to get what you probably intended, use <code>[\t\v]</code> for &ldquo;a tab or any vertical spacing character&rdquo;, or <code>[\t\r\n]</code> for &ldquo;a tab or carriage return or newline but not any of the weird verticals&rdquo;.</li>
</ul>

<h4 id="ranges-or-kinds-of-characters">Ranges or kinds of characters</h4>

<h5 id="character-classes">Character Classes</h5>

<ul>
<li><p><code>[</code><em>set</em><code>]</code>  ⇒ This indicates a <em>set</em> of characters, for example, <code>[abc]</code> means any of the literal characters <code>a</code>, <code>b</code> or <code>c</code>. You can also use ranges by putting a hyphen between characters, for example <code>[a-z]</code> for any character from <code>a</code> to <code>z</code>.  You can use a collating sequence in character ranges, like in <code>[[.ch.]-[.ll.]]</code> (these are collating sequences in Spanish).
Certain characters require special treatment inside character classes:</p>

<ul>
<li><p>To use a literal <code>-</code> in a character class:  Use it directly as the first or last character in the enclosing class notation, like <code>[-abc]</code> or <code>[abc-]</code>; OR use it &ldquo;escaped&rdquo; at any position, like <code>[\-abc]</code> or <code>[a\-bc]</code> .</p></li>

<li><p>To use a literal <code>]</code> in a character class:  Use it directly right after the opening <code>[</code> of the class notation, like <code>[]abc]</code>; OR use it &ldquo;escaped&rdquo; at any position, like <code>[\]abc]</code> or <code>[a\]bc]</code> .</p></li>

<li><p>To use a literal <code>[</code> in a character class:  Use it directly like any other character, like <code>[ab[c]</code>; &ldquo;escaping&rdquo; is not necessary, but is permissible, like <code>[ab\[c]</code> .  This character is not special when used <em>alone</em> inside a class; however, there are cases where it <em>is</em> special in combination with another:</p>

<ul>
<li><p>If used with a colon in the order <code>[:</code> inside a class, it is the opening sequence for a named class (described below); if you want to include both a <code>[</code> and a <code>:</code> inside the same character class, do not use them unescaped right next to each other; either change the order, like <code>[:[]</code>, or escape one or both, like <code>[\[:]</code> or <code>[[\:]</code> or <code>[\[\:]</code> .</p></li>

<li><p>If used with an equals sign in the order <code>[=</code> inside a class, it is the opening sequence for an equivalence class (described below); if you want to include both a <code>[</code> and a <code>=</code> inside the same character class, do not use them unescaped right next to each other; either change the order, like <code>[=[]</code>, or escape one or both, like <code>[\[=]</code> or <code>[[\=]</code> or <code>[\[\=]</code> .</p></li>
</ul></li>

<li><p>To use a literal <code>\</code> in a character class, it must be doubled (i.e., <code>\\</code>) inside the enclosing class notation, like <code>[ab\\c]</code> .</p></li>

<li><p>To use a literal <code>^</code> in a character class: Use it directly as any character but the first, such as <code>[a^b]</code> or <code>[ab^]</code>; OR use it &ldquo;escaped&rdquo; at any position, such as <code>[\^ab]</code> or <code>[a\^b]</code> or <code>[ab\^]</code> .</p></li>
</ul></li>

<li><p><code>[^</code><em>set</em><code>]</code>  ⇒ The complement of the characters in the <em>set</em>. For example, <code>[^A-Za-z]</code> means any character except an alphabetic character.  Care should be taken with a complement list, as regular expressions are always multi-line, and hence <code>[^ABC]*</code> will match until the first <code>A</code>, <code>B</code> or <code>C</code> (or <code>a</code>, <code>b</code> or <code>c</code> if match case is off), including any newline characters. To confine the search to a single line, include the newline characters in the exception list, e.g. <code>[^ABC\r\n]</code>.</p></li>

<li><p><code>[[:</code><em>name</em><code>:]]</code> or <code>[[:☒:]]</code> ⇒ The whole character class named <em>name</em>.  For many, there is also a single-letter &ldquo;short&rdquo; class name, ☒.  Please note: the <code>[:</code><em>name</em><code>:]</code> and <code>[:☒:]</code> must be inside a character class <code>[...]</code> to have their special meaning.</p>

<table>
<thead>
<tr>
<th align="center">short</th>
<th align="center">full name</th>
<th align="left">description</th>
<th>equivalent character class</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"></td>
<td align="center">alnum</td>
<td align="left">letters and digits</td>
<td></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">alpha</td>
<td align="left">letters</td>
<td></td>
</tr>

<tr>
<td align="center">h</td>
<td align="center">blank</td>
<td align="left">spacing which is not a line terminator</td>
<td><code>[\t\x20\xA0]</code></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">cntrl</td>
<td align="left">control characters</td>
<td><code>[\x00-\x1F\x7F\x81\x8D\x8F\x90\x9D]</code></td>
</tr>

<tr>
<td align="center">d</td>
<td align="center">digit</td>
<td align="left">digits</td>
<td></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">graph</td>
<td align="left">graphical character, so essentially any character except for control chars, <code>\0x7F</code>, <code>\x80</code></td>
<td></td>
</tr>

<tr>
<td align="center">l</td>
<td align="center">lower</td>
<td align="left">lowercase letters</td>
<td></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">print</td>
<td align="left">printable characters</td>
<td><code>[\s[:graph:]]</code></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">punct</td>
<td align="left">punctuation characters</td>
<td><code>[!&quot;#$%&amp;'()*+,\-./:;&lt;=&gt;?@\[\\\]^_{\|}~]</code></td>
</tr>

<tr>
<td align="center">s</td>
<td align="center">space</td>
<td align="left">whitespace (word or line separator)</td>
<td><code>[\t\n\x0B\f\r\x20\x85\xA0\x{2028}\x{2029}]</code></td>
</tr>

<tr>
<td align="center">u</td>
<td align="center">upper</td>
<td align="left">uppercase letters</td>
<td></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">unicode</td>
<td align="left">any character with code point above 255</td>
<td><code>[\x{0100}-\x{FFFF}]</code></td>
</tr>

<tr>
<td align="center">w</td>
<td align="center">word</td>
<td align="left">word characters</td>
<td><code>[_\d\l\u]</code></td>
</tr>

<tr>
<td align="center"></td>
<td align="center">xdigit</td>
<td align="left">hexadecimal digits</td>
<td><code>[0-9A-Fa-f]</code></td>
</tr>
</tbody>
</table>

<p>Note that letters include any unicode letters (ASCII letters, accented letters, and letters from a variety of other writing systems); digits include ASCII numeric digits, and anything else in Unicode that&rsquo;s classified as a digit (like superscript numbers ¹²³&hellip;).</p>

<p>Note that those character class names may be written in upper or lower case without changing the results.  So <code>[[:alnum:]]</code> is the same as <code>[[:ALNUM:]]</code> or the mixed-case <code>[[:AlNuM:]]</code>.</p>

<p>As stated earlier, the <code>[:</code><em>name</em><code>:]</code> and <code>[:☒:]</code> (note the single brackets) must be a part of a surrounding character class.  However, you <em>may</em> combine them inside one character class, such as <code>[_[:d:]x[:upper:]=]</code>, which is a character class that would match any digit, any uppercase, the lowercase <code>x</code>, and the literal <code>_</code> and <code>=</code> characters.  These named classes won&rsquo;t always appear with the double brackets, but they will always be inside of a character class.</p>

<p>If the <code>[:</code><em>name</em><code>:]</code> or <code>[:☒:]</code> are accidentally <em>not</em> contained inside a surrounding character class, they will lose their special meaning.  For example, <code>[:upper:]</code> is the character class matching <code>:</code>, <code>u</code>, <code>p</code>, <code>e</code>, and <code>r</code>; whereas <code>[[:upper:]]</code> is similar to <code>[A-Z]</code> (plus other unicode uppercase letters)</p></li>

<li><p><code>[^[:</code><em>name</em><code>:]]</code> or <code>[^[:☒:]]</code> ⇒ The complement of character class named <em>name</em> or ☒ (matching anything <em>not</em> in that named class).  This uses the same long names, short names, and rules as mentioned in the previous description.</p></li>

<li><p>Character classes may <em>not</em> contain parentheses-based groups of any kind, including the special escape <code>\R</code> (which expands to a parentheses-based group when evaluated, even though <code>\R</code> doesn&rsquo;t look like it contains parentheses).</p></li>
</ul>

<h5 id="character-properties">Character Properties</h5>

<p>These properties behave similar to named character classes, but cannot be contained inside a character class.</p>

<ul>
<li><p><code>\p☒</code> or <code>\p{</code><em>name</em><code>}</code> ⇒ Same as <code>[[:☒:]]</code> or <code>[[:</code><em>name</em><code>:]]</code>, where ☒ stands for one of the short names from the table above, and <em>name</em> stands for one of the full names from above. For instance, <code>\pd</code> and <code>\p{digit}</code> both stand for a digit, just like the escape sequence <code>\d</code> does.</p></li>

<li><p><code>\P☒</code> or <code>\P{</code><em>name</em><code>}</code> ⇒ Same as <code>[^[:☒:]]</code> or <code>[^[:</code><em>name</em><code>:]]</code> (not belonging to the class <em>name</em>).</p></li>
</ul>

<h5 id="character-escape-sequences">Character escape sequences</h5>

<p><code>\☒</code> ⇒ Where ☒ is one of <code>d</code>, <code>w</code>, <code>l</code>, <code>u</code>, <code>s</code>, <code>h</code>, <code>v</code>, described below.  These single-letter escape sequences are each equivalent to a class from above.  The lower-case escape sequence means it matches that class; the upper-case escape sequence means it matches the negative of that class.  (Unlike the properties, these can be used both inside or outside of a character class.)</p>

<table>
<thead>
<tr>
<th align="left">Description</th>
<th align="left">Escape Sequence</th>
<th align="left">Positive Class</th>
<th align="left">Negative Escape Sequence</th>
<th align="left">Negative Class</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">digits</td>
<td align="left"><code>\d</code></td>
<td align="left"><code>[[:digit:]]</code></td>
<td align="left"><code>\D</code></td>
<td align="left"><code>[^[:digit:]]</code></td>
</tr>

<tr>
<td align="left">word chars</td>
<td align="left"><code>\w</code></td>
<td align="left"><code>[[:word:]]</code></td>
<td align="left"><code>\W</code></td>
<td align="left"><code>[^[:word:]]</code></td>
</tr>

<tr>
<td align="left">lowercase</td>
<td align="left"><code>\l</code></td>
<td align="left"><code>[[:lower:]]</code></td>
<td align="left"><code>\L</code></td>
<td align="left"><code>[^[:lower:]]</code></td>
</tr>

<tr>
<td align="left">uppercase</td>
<td align="left"><code>\u</code></td>
<td align="left"><code>[[:upper:]]</code></td>
<td align="left"><code>\U</code></td>
<td align="left"><code>[^[:upper:]]</code></td>
</tr>

<tr>
<td align="left">word/line separators</td>
<td align="left"><code>\s</code></td>
<td align="left"><code>[[:space:]]</code></td>
<td align="left"><code>\S</code></td>
<td align="left"><code>[^[:space:]]</code></td>
</tr>

<tr>
<td align="left">horizontal space</td>
<td align="left"><code>\h</code></td>
<td align="left"><code>[[:blank:]]</code></td>
<td align="left"><code>\H</code></td>
<td align="left"><code>[^[:blank:]]</code></td>
</tr>

<tr>
<td align="left">vertical space</td>
<td align="left"><code>\v</code></td>
<td align="left">see below</td>
<td align="left"><code>\V</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>

<blockquote>
<p>Vertical space: This encompasses all the <code>[[:space:]]</code> characters that aren&rsquo;t <code>[[:blank:]]</code> characters: The LF, VT, FF, CR , NEL control characters and the LS and PS format characters: 0x000A (line feed), 0x000B (vertical tabulation), 0x000C (form feed), 0x000D (carriage return), 0x0085 (next line), 0x2028 (line separator) and 0x2029 (paragraph separator).  There isn&rsquo;t a named class which matches.</p>
</blockquote>

<p><em>Note</em>: despite its similarity to <code>\v</code>, even though <code>\R</code> matches certain vertical space characters, it is <em>not</em> a character-class-equivalent escape sequence (because it evaluates to a parentheses<code>()</code>-based expression, not a class-based expression).  So while <code>\d</code>, <code>\l</code>, <code>\s</code>, <code>\u</code>, <code>\w</code>, <code>\h</code>, and <code>\v</code> are all equivalent to a character class and can be included inside another bracket<code>[]</code>-based character class, the <code>\R</code> is <em>not</em> equivalent to a character class, and <em>cannot</em> be included inside a bracketed<code>[]</code> character-class.</p>

<h5 id="equivalence-classes">Equivalence Classes</h5>

<ul>
<li><code>[[=</code><em>char</em><code>=]]</code> ⇒ All characters that differ from <em>char</em> by case, accent or similar alteration only. For example <code>[[=a=]]</code> matches any of the characters: <code>A</code>, <code>À</code>, <code>Á</code>, <code>Â</code>, <code>Ã</code>, <code>Ä</code>, <code>Å</code>, <code>a</code>, <code>à</code>, <code>á</code>, <code>â</code>, <code>ã</code>, <code>ä</code> and <code>å</code>.</li>
</ul>

<h4 id="multiplying-operators">Multiplying operators</h4>

<ul>
<li><p><code>+</code>  ⇒ This matches 1 or more instances of the previous character, as many as it can. For example, <code>Sa+m</code> matches <code>Sam</code>, <code>Saam</code>, <code>Saaam</code>, and so on.  <code>[aeiou]+</code> matches consecutive strings of vowels.</p></li>

<li><p><code>*</code>  ⇒ This matches 0 or more instances of the previous character, as many as it can. For example, <code>Sa*m</code> matches <code>Sm</code>, <code>Sam</code>, <code>Saam</code>, and so on.</p></li>

<li><p><code>?</code> ⇒ Zero or one of the last character. Thus <code>Sa?m</code> matches <code>Sm</code> and <code>Sam</code>, but not <code>Saam</code>.</p></li>

<li><p><code>*?</code> ⇒ Zero or more of the previous group, but minimally: the shortest matching string, rather than the longest string as with the &ldquo;greedy&rdquo; operator. Thus, <code>m.*?o</code> applied to the text <code>margin-bottom: 0;</code> will match <code>margin-bo</code>, whereas <code>m.*o</code> will match <code>margin-botto</code>.</p></li>

<li><p><code>+?</code> ⇒ One or more of the previous group, but minimally.</p></li>

<li><p><code>{ℕ}</code> ⇒ Matches ℕ copies of the element it applies to (where ℕ is any decimal number).</p></li>

<li><p><code>{ℕ,}</code> ⇒ Matches ℕ or more copies of the element it applies to.</p></li>

<li><p><code>{ℕ,ℙ}</code> ⇒ Matches ℕ to ℙ copies of the element it applies to, as much it can (where ℙ ≥ ℕ).</p></li>

<li><p><code>{ℕ,}?</code> or <code>{ℕ,ℙ}?</code> ⇒ Like the above, but minimally.</p></li>

<li><p><code>*+</code> or <code>?+</code> or <code>++</code> or <code>{ℕ,}+</code> or <code>{ℕ,ℙ}+</code> ⇒ These so called &ldquo;possessive&rdquo; variants of greedy repeat marks do not backtrack. This allows failures to be reported much earlier, which can boost performance significantly. But they will eliminate matches that would require backtracking to be found. As an example, see how the matching engine handles the following two regexes:</p>

<p>When regex <code>“.*”</code> is run against the text <code>“abc”x</code> :</p>

<pre><code>`“`  matches `“`
`.*` matches `abc”x`
`”`  doesn't match ( End of line ) =&gt; Backtracking
`.*` matches `abc”`
`”`  doesn't match letter `x` =&gt; Backtracking
`.*` matches `abc`
`”`  matches `”` =&gt; 1 overall match `“abc”`
</code></pre>

<p>When regex <code>“.*+”</code>, with a possessive quantifier, is run against the text <code>“abc”x</code> :</p>

<pre><code>`“`   matches `“`
`.*+` matches `abc”x` ( catches all remaining characters )
`”`   doesn't match ( End of line )
</code></pre>

<p>Notice there is no match at all in this version, because the possessive quantifier prevents backtracking to a possible solution.</p></li>
</ul>

<h4 id="anchors">Anchors</h4>

<p>Anchors match a zero-length position in the line, rather than a particular character.</p>

<ul>
<li><p><code>^</code> ⇒ This matches the start of a line (except when used inside a set, see above).</p></li>

<li><p><code>$</code>  ⇒ This matches the end of a line.</p></li>

<li><p><code>\&lt;</code>  ⇒ This matches the start of a word using Scintilla&rsquo;s definition of words.</p></li>

<li><p><code>\&gt;</code>  ⇒ This matches the end of a word using Scintilla&rsquo;s definition of words.</p></li>

<li><p><code>\b</code> ⇒ Matches either the start or end of a word.</p></li>

<li><p><code>\B</code> ⇒ Not a word boundary. It represents any location between two word characters or between two non-word characters.</p></li>

<li><p><code>\A</code> or <code>\`</code> ⇒ Matches the start of the file.</p></li>

<li><p><code>\z</code> or <code>\'</code> ⇒ Matches the end of the file.</p></li>

<li><p><code>\Z</code> ⇒ Matches like <code>\z</code> with an optional sequence of newlines before it. This is equivalent to <code>(?=\v*\z)</code>, which departs from the traditional Perl meaning for this escape.</p></li>

<li><p><code>\G</code> ⇒ This &ldquo;Continuation Escape&rdquo; matches the end of the previous match.  In <strong>Find All</strong> or <strong>Replace All</strong> circumstances, this will allow you to anchor your next match at the end of the previous match.  If it is the first match of a <strong>Find All</strong> or <strong>Replace All</strong>, and any time you use a single <strong>Find Next</strong> or <strong>Replace</strong>, the &ldquo;end of previous match&rdquo; is defined to be the start of the search area &ndash; the beginning of the document, or the current caret position, or the start of the highlighted text.</p></li>
</ul>

<h4 id="capture-groups-and-backreferences">Capture Groups and Backreferences</h4>

<ul>
<li><p><code>(</code><em>subset</em><code>)</code> ⇒ <em>Numbered Capture Group</em>: Parentheses mark a part of the regular expression, also known as a <em>subset</em> expression or capture group. The string matched by the contents of the parentheses (indicated by <em>subset</em> in this example) can be re-used with a backreference or as part of a replace operation; see <a href="#substitutions">Substitutions</a>, below. Groups may be nested.</p></li>

<li><p><code>(?&lt;name&gt;</code><em>subset</em><code>)</code> or <code>(?'name'</code><em>subset</em><code>)</code> ⇒ <em>Named Capture Group</em>: Names the value matched by <em>subset</em> as the group <em>name</em>.  Please note that group names are case-sensitive.</p></li>

<li><p><code>\ℕ</code>, <code>\gℕ</code>, <code>\g{ℕ}</code>, <code>\g&lt;ℕ&gt;</code>, <code>\g'ℕ'</code>, <code>\kℕ</code>, <code>\k{ℕ}</code>, <code>\k&lt;ℕ&gt;</code> or <code>\k'ℕ'</code> ⇒ <em>Numbered Backreference:</em> These syntaxes match the ℕth capture group earlier in the same expression.  (Backreferences are used to refer to the capture group contents only in the search/match expression; see the <a href="#substitution-escape-sequences">Substitution Escape Sequences</a> for how to refer to capture groups in substitutions/replacements.)</p>

<p>A regex can have multiple subgroups, so <code>\2</code>, <code>\3</code>, etc. can be used to match others (numbers advance left to right with the opening parenthesis of the group).  You can have as many capture groups as you need, and are not limited to only 9 groups (though some of the syntax variants can only reference groups 1-9; see the notes below, and use the syntaxes that explicitly allow multi-digit ℕ if you have more than 9 groups)</p>

<ul>
<li><p>Example: <code>([Cc][Aa][Ss][Ee]).*\1</code> would match a line such as <code>Case matches Case</code> but not <code>Case doesn't match cASE</code>.</p></li>

<li><p><code>\ℕ</code> ⇒ This form can only have ℕ as digits 1-9, so if you have more than 9 capture groups, you will have to use one of the other numbered backreference notations, listed in the next bullet point.</p>

<p>Example: the expression <code>\10</code> matches the contents of the first capture group <code>\1</code> followed by the literal character <code>0</code>&rdquo;, <em>not</em> the contents of the 10th group.</p></li>

<li><p><code>\gℕ</code>, <code>\g{ℕ}</code>, <code>\g&lt;ℕ&gt;</code>, <code>\g'ℕ'</code>, <code>\kℕ</code>, <code>\k{ℕ}</code>, <code>\k&lt;ℕ&gt;</code> or <code>\k'ℕ'</code> ⇒ These forms can handle any non-zero ℕ.</p>

<ul>
<li><p>For positive ℕ, it matches the ℕth subgroup, even if ℕ has more than one digit.  <code>\g10</code> matches the contents from the 10th capture group, <em>not</em> the contents from the first capture group followed by the literal <code>0</code>.</p>

<ul>
<li><p>If you want to match a literal number after the contents of the ℕth capture group, use one of the forms that has braces, brackets, or quotes, like <code>\g{ℕ}</code> or <code>\k'ℕ'</code> or <code>\k&lt;ℕ&gt;</code>: For example, <code>\g{2}3</code> matches the contents of the second capture group, followed by a literal 3, whereas <code>\g23</code> would match the contents of the twenty-third capture group.</p></li>

<li><p>For clarity, it is highly recommended to always use the braces or brackets form for multi-digit ℕ</p></li>
</ul></li>

<li><p>For negative ℕ, groups are counted backwards relative to the last group, so that <code>\g{-1}</code> is the last matched group, and <code>\g{-2}</code> is the next-to-last matched group.</p>

<ul>
<li><p>Please, note the difference between absolute and relative backreferences. For instance, an exact four-letters word palindrome can be matched with :</p>

<ul>
<li><p>the regex <code>(?-i)\b(\w)(\w)\g{2}\g{1}\b</code>, when using absolute (positive) coordinates</p></li>

<li><p>the regex <code>(?-i)\b(\w)(\w)\g{-1}\g{-2}\b</code>, when using relative (negative) coordinates</p></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>

<li><p><code>\g{name}</code>, <code>\g&lt;name&gt;</code>, <code>\g'name'</code>, <code>\k{name}</code>, <code>\k&lt;name&gt;</code> or <code>\k'name'</code> ⇒ <em>Named Backreference</em>: The string matching the subexpression named <em>name</em>.  (As with the Numbered Backreferences above, these Named Backreferences are used to refer to the capture group contents only in the search/match expression; see the <a href="#substitution-escape-sequences">Substitution Escape Sequences</a> for how to refer to capture groups in substitutions/replacements.)</p></li>
</ul>

<h4 id="readability-enhancements">Readability enhancements</h4>

<ul>
<li><p><code>(?:</code><em>subset</em><code>)</code> ⇒ A non-capturing grouping construct for the <em>subset</em> expression that doesn&rsquo;t count as a subexpression (doesn&rsquo;t get numbered or named), but just groups things for easier reading of the regex, or for using a quantified amount of that group, with a quantifier located right after that grouping construct.</p></li>

<li><p><code>(?#</code><em>comment</em><code>)</code> ⇒ Comments. The whole group is for humans only and will be ignored in matching text.</p></li>
</ul>

<p>Using the x flag modifier (see section below) is also a good way to improve readability in complex regular expressions.</p>

<h4 id="search-modifiers">Search modifiers</h4>

<p>The following constructs control how matches condition other matches, or otherwise alter the way search is performed.</p>

<ul>
<li><p><code>\Q</code> ⇒ Starts verbatim mode (Perl calls it &ldquo;quoted&rdquo;). In this mode, all characters are treated as-is, the only exception being the <code>\E</code> end verbatim mode sequence.</p></li>

<li><p><code>\E</code> ⇒ Ends verbatim mode. Thus, <code>\Q\*+\Ea+</code> matches <code>\*+aaaa</code>.</p></li>

<li><p><code>(?enable-disable)</code> or <code>(?enable-disable:subpattern)</code> ⇒ There are four flags, described below, which can be applied to a regex or subgroup.  The <em>enable</em> term can be made up of 0-4 of the flags described below; the <em>disable</em> term can be made up of 0-4 of the flags described below. Any flags in <em>enable</em> will be enabled (turned on); any flags in <em>disable</em> will be disabled (turned off).  (Remember, it does not make sense to include the same flag in both the <em>enable</em> and <em>disable</em> terms.)  If there are no <em>disable</em> flags, the <code>-</code> is not necessary; if there are no <em>enable</em> flags, then the <code>-</code> will come immediately after the <code>?</code>: <code>(?-...)</code>.  If there is a subpattern, then the flags only apply for the contents of the subpattern; without a subpattern, there is no <code>:</code> separator, and the flags apply for the remainder of the current regex, or until the next flags are set.</p>

<ul>
<li><code>i</code> ⇒ case insensitive (default: set by <strong>☐ Match case</strong> dialog option)</li>
<li><code>m</code> ⇒ ^ and $ match embedded newlines (default: on)</li>
<li><code>s</code> ⇒ dot matches newline (default: as per <strong>☐ . matches newline</strong> dialog option)</li>
<li><code>x</code> ⇒ Ignore non-escaped whitespace in regex (default: off).  Any whitespace that you need to match must be escaped.  This is also known as &ldquo;free-spacing mode&rdquo;</li>
</ul>

<p>Examples:</p>

<ul>
<li><code>blah(?i-s)foobar</code> ⇒ enables case insensitivity and disables dot-matches-newline for the rest of the regular expression: thus expression <code>blah</code> is run under the default rules (set by the dialog), whereas expression <code>foobar</code> will be case-insensitive and dot will not match newline.</li>
<li><code>(?i-s:subpattern)</code> ⇒ enables case insensitivity and disables dot-matches-newline, but just for the <code>subpattern</code></li>
<li><code>(?-i)caseSensitive(?i)cAsE inSenSitive</code> ⇒ disables case insensitivity (makes it case-sensitive) for the portion of the regex indicated by <code>caseSensitive</code>, and re-enables case-insensitive matching for the rest of the regex</li>
<li><code>(?m:justHere)</code> ⇒ <code>^</code> and <code>$</code> will match on embedded newlines, but just for the contents of this subgroup <code>justHere</code></li>
<li><code>(?x)</code> ⇒ Allow extra whitespace in the expression for the remainder of the regex</li>
</ul>

<p>Please note that turning off &ldquo;dot matches newline&rdquo; with <code>(?-s)</code> will <em>not</em> affect character classes: <code>(?-s)[^x]+</code> will match 1 or more instances of any non-<code>x</code> character, including newlines, even though the <code>(?-s)</code> <a href="#search-modifier">search modifier</a> turns off &ldquo;dot matches newlines&rdquo; (the <code>[^x]</code> is <em>not</em> a dot <code>.</code>, so is still allowed to match newlines).</p>

<p>More on free-spacing mode <code>(?x)</code>:</p>

<ul>
<li>As with all these flags, this is for the search (&ldquo;Find what&rdquo; box) only; it does not work for the substitution (&ldquo;Replace with&rdquo; box).</li>
<li>As said before, this mode ignores whitespace: this includes space, tabs, newlines, and other fancy Unicode space-like characters.  If you want to <em>match</em> a whitespace character, it must be escaped (using the escapes described earlier in the regex documentation), or put inside a character class.

<ul>
<li>Example: the regex <code>(?x)one two</code> will match the text <code>onetwo</code>, but <em>not</em> the text <code>one two</code>.  <code>(?x) one \x20 two</code> could be used to match <code>one two</code>.</li>
<li>Spaces inside character classes will <em>not</em> be ignored: <code>(?x)one [ ] two</code> <em>will</em> match <code>one two</code>.</li>
</ul></li>
<li>Inside free-spacing mode, <code>#</code> makes the rest of the line of the regex a &ldquo;comment&rdquo;, rather than text-to-match.  So if you want to match a literal <code>#</code> character in a free-spacing-mode regex, encode it in some manner, such as <code>\x23</code> or <code>\#</code> or <code>[#]</code>.

<ul>
<li><p>Example: to match <code>match this phrase</code> in free-spacing mode, with a comment in the regex:</p>

<pre><code>(?x) match \h this \x20 phrase  # enable free-spacing mode; note spaces must be matched with \h or \x20 or [ ], and # with \x23 or [#]
</code></pre></li>

<li><p>Because Notepad++&rsquo;s regex input field only allows you to enter a single line, you cannot use free-spacing mode to its full multi-line extent, when using the GUI.</p>

<ul>
<li>However, in the <a href="../function-list/index.html#how-to-customize-function-list">Function List parser definitions</a>, which use the same regex syntax, you <em>can</em> use multi-line regex in free-spacing mode, since it doesn&rsquo;t have the GUI limitation.</li>
</ul></li>
</ul></li>
</ul></li>

<li><p><code>(?|expression)</code> ⇒ &ldquo;Branch Reset&rdquo; ⇒ If an alternation expression has parenthetical subexpressions in some of its alternatives, this construction will allow the subexpression counter not to be altered by what is in the other branches of the alternation.</p>

<p>Put differently, in a normal match, each capture group will increment one counter from the capture-group started to its left; in a branch reset, each alternative resets the capture-group counter, and any capture groups <em>after</em>  the branch reset construct will continue numbering based on the largest group number found in one of the branch-reset alternatives.</p>

<p>For example, consider these two expressions that use alternations, the first one using the non-capture group indicator containing three alternatives, and the second using the branch-reset mechanism containing three alternatives:</p>

<pre><code>#    -------------------example without branch-reset-----------------
(?x) ( a )  (?: x ( y ) z | (p (q) r) | (t) u (v) ) ( z )
#      1   skip     2        3  4        5     6      7  &lt;=== assigned subexpression counter values
#               first     | second    |  third           &lt;=== alternatives

#              ---------example with branch-reset---------
(?x) ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z )
#      1   skip     2        2  3        2     3      4  &lt;=== assigned subexpression counter values
#               first     | second    |  third           &lt;=== alternatives
</code></pre>

<table>
<thead>
<tr>
<th>example text</th>
<th>which alternative is chosen</th>
<th>group contents without branch reset</th>
<th>group contents with branch reset</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>axyzz</code></td>
<td>first</td>
<td>1=<code>a</code>, 2=<code>y</code>, 3=4=5=6=empty, 7=<code>z</code></td>
<td>1=<code>a</code>, 2=<code>y</code>, 3=empty, 4=<code>z</code></td>
</tr>

<tr>
<td><code>apqrz</code></td>
<td>second</td>
<td>1=<code>a</code>, 2=empty, 3=<code>pqr</code>, 4=<code>q</code>, 5=6=empty, 7=<code>z</code></td>
<td>1=<code>a</code>, 2=<code>pqr</code>, 3=<code>q</code>, 4=<code>z</code></td>
</tr>

<tr>
<td><code>atuvz</code></td>
<td>third</td>
<td>1=<code>a</code>, 2=3=4=empty, 5=<code>t</code>, 6=<code>v</code>, 7=<code>z</code></td>
<td>1=<code>a</code>, 2=<code>t</code>, 3=<code>v</code>, 4=<code>z</code></td>
</tr>
</tbody>
</table>

<p>Two things to note for the branch-reset example:</p>

<ol>
<li>As with the <code>(?:...)</code> non-capture grouping indicator in the no-branch-reset, the <code>(?|...)</code> branch-reset indicator does not represent a capture-group and gets no group number for itself (hence the &ldquo;skip&rdquo;)</li>
<li>It is allowed for one or more alternatives to have fewer capture-group subexpressions defined than other alternates: this means that some group number contents will not be defined if that alternate matches, as is shown by &ldquo;empty&rdquo; in the table of results above.</li>
</ol></li>
</ul>

<h3 id="control-flow">Control flow</h3>

<p>Normally, a regular expression parses from left to right linearly. But you may need to change this behavior.</p>

<ul>
<li><p><code>|</code> ⇒ The alternation operator, which allows matching either of a number of options.  For example, <code>one|two|three</code> will match either of <code>one</code>, <code>two</code> or <code>three</code>. Matches are attempted from left to right. Use <code>(?:)</code> inside the alternation to have one of the alternates match an empty string: the subexpression <code>(A|BC|(?:))</code> will capture <code>A</code> or <code>BC</code> or an empty string into that capture-group.</p></li>

<li><p><code>(?ℕ)</code> ⇒ Refers to ℕth subexpression (the regex in the expression, not the text matched). If ℕ is negative, it will use the ℕth subexpression from the end.</p>

<p>This is often called a numbered &ldquo;recursion&rdquo;, because it acts like a recursive call to execute the same subexpression at multiple places in your full expression without copy/pasting it.</p>

<p>Please note the difference between the meaning of a numbered recursion and a normal numbered <a href="%5bbackreference%5d(#capture-groups-and-backreferences)">backreference</a>: A normal back-reference is a way to refer to the <em>values</em> from previous capture groups later in the full expression.  This numbered recursion syntax, on the other hand, refers to to the underlying regex from the previous subexpression, not its value.</p>

<p>Using an example similar to the backreference palindrome example: With the recursion, both regexes just find any four-letter word, because each subexpression, signed or not, refers to the regex itself, not to the specific value found earlier by each group!</p>

<ul>
<li><p>The regex <code>(?-i)\b(\w)(\w)(?2)(?1)\b</code> finds a four-letter word, when using absolute coordinates.</p></li>

<li><p>The regex <code>(?-i)\b(\w)(\w)(?-1)(?-2)\b</code> finds a four-letter word, when using relative coordinates.</p></li>
</ul>

<p>These two expressions are actually both equivalent to <code>(?-i)\b(\w)(\w)\w\w\b</code>; there is no good reason for using recursions here.</p>

<p>Numbered recursions really shine when you want to match the same complicated rules at multiple points in the expression.</p></li>

<li><p><code>(?0)</code> or <code>(?R)</code> ⇒ Backtrack to start of pattern.  This recursively reruns the same expression from the start of the full expression to the very end (even beyond this backtrack).  This is sometimes called  &ldquo;whole-match recursion&rdquo;.</p>

<p>This is useful for requiring some sub-portion of the pattern to match according to the same rules.</p>

<p>For example, to find balanced {} with any number of spaces inside or out, and any number of balanced copies next to each other, use the regular expression <code>{\h*(?0)*\h*}\h*</code>:</p>

<table>
<thead>
<tr>
<th>text</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>{ }</code></td>
<td>matches</td>
</tr>

<tr>
<td><code>{ { } }</code></td>
<td>matches whole string</td>
</tr>

<tr>
<td><code>{ { { } } {} }</code></td>
<td>matches whole string</td>
</tr>

<tr>
<td><code>{ { { } } {}</code></td>
<td>two matches, <code>{ { } }</code> and <code>{}</code>, where the first <code>{</code> is not matched at all, because it is not balanced with any closing <code>}</code></td>
</tr>
</tbody>
</table></li>

<li><p><code>(?&amp;name)</code> or <code>(?P&gt;name)</code> ⇒ Backtrack to subexpression named <em>name</em>.  This is known as &ldquo;named recursion&rdquo;.</p>

<ul>
<li><p>If a non-signed subexpression is located OUTSIDE the parentheses of the group to which it refers, it is called a subroutine call</p></li>

<li><p>If a non-signed subexpression is located INSIDE the parentheses of the group to which it refers, it is called a recursive call</p></li>
</ul></li>

<li><p><code>(?(assertion)YesPattern|NoPattern)</code> ⇒ Conditional Expressions</p>

<p>If the <em>assertion</em> is true, then <em>YesPattern</em> will be used for matching the text; if the <em>assertion</em> is false, then <em>NoPattern</em> will be used for matching the text.</p>

<p><em>YesPattern</em> and <em>NoPattern</em> are any valid regex patterns.</p>

<p>The <em>assertion</em> will always be inside parentheses; this is emphasized by including the parentheses in the list of supported <em>assertion</em> syntax, below:</p>

<ul>
<li><p><code>(ℕ)</code> ⇒ true if ℕth unnamed group was previously defined</p></li>

<li><p><code>(&lt;name&gt;)</code> or <code>('name')</code> ⇒ true if group called <em>name</em> was previously defined</p></li>

<li><p><code>(?=lookahead)</code> ⇒ true if the <em>lookahead</em> expression matches</p></li>

<li><p><code>(?!lookahead)</code> ⇒ true if the <em>lookahead</em> expression does not match</p></li>

<li><p><code>(?&lt;=lookbehind)</code> ⇒ true if the <em>lookbehind</em> expression matches</p></li>

<li><p><code>(?&lt;!lookbehind)</code> ⇒ true if the <em>lookbehind</em> expression does not match</p></li>

<li><p><code>(R)</code> ⇒ true if inside a recursion</p></li>

<li><p><code>(Rℕ)</code> ⇒ true if in a recursion to subexpression numbered ℕ</p></li>

<li><p><code>(R&amp;name)</code> ⇒ true if in a recursion to named subexpression <em>name</em></p></li>
</ul>

<p>Note: These are all still <em>inside</em> the conditional expression.</p>

<p>Do not confuse the assertions that control a conditional expression (here) with the assertions that are part of the pattern matching (the <a href="#assertions">Assertions</a> section, below).  Here, the assertion is used to decide which expression is used; below, the assertion decides whether the pattern is matching or not.</p>

<p>Note: PCRE doesn&rsquo;t treat recursion expressions like Perl does:</p>

<blockquote>
<p>In PCRE (like Python, but unlike Perl), a recursive subpattern call  is
always treated as an atomic group. That is, once it has matched some of
the subject string, it is never re-entered, even if it contains untried
alternatives  and  there  is a subsequent matching failure.</p>
</blockquote></li>

<li><p><code>(?&gt;pattern)</code> ⇒ Independent sub-expression</p>

<p>Match <em>pattern</em> independently of surrounding patterns. Search will never backtrack into independent sub-expression.</p>

<p>Independent sub-expressions are typically used to improve performance, because only the best possible match for pattern will be considered; if this doesn&rsquo;t allow the expression as a whole to match then no match is found at all.</p>

<p>It can also be used to keep the logic for Conditional Expressions (above) correct, preventing an unexpected path to the wrong alternative being used.  For example, when using a group-number as the conditional assertion, <code>(?(ℕ)YesPattern|NoPattern)</code>:</p>

<ul>
<li><p>The regex <code>(?:(100)|\d{3}) apples (?(1)YesPattern|NoPattern)</code> does not use the independent sub-expression, so it will find <code>100 apples NoPattern</code>, even though you expected <code>YesPattern</code> to be used when <code>100</code> was matched.  Why? If <code>YesPattern</code> failed, the search will backtrack to the beginning and try next alternative, where <code>100</code> matches <code>\d{3}</code>, but that means that <code>?(1)</code> does <em>not</em> match so the conditional expression uses <code>NoPattern</code>.</p></li>

<li><p>Instead, you can use the independent sub-expression to prevent backtracking, by using the regex <code>(?&gt;(100)|\d{3}) apples (?(1)YesPattern|NoPattern)</code>.  Now, if <code>YesPattern</code> fails, it cannot backtrack to use the <code>\d{3}</code>, thus preventing it from accidentally using <code>100 apples NoPattern</code>, so with <code>100</code> it will either match <code>100 apples YesPattern</code> or the whole expression will fail.</p></li>
</ul></li>

<li><p><code>\K</code> ⇒ Resets matched text at this point. For instance, matching <code>foo\Kbar</code> will not match <code>bar</code>. It will match <code>foobar</code>, but will pretend that only <code>bar</code> matches. Useful when you wish to replace only the tail of a matched subject and groups are clumsy to formulate.</p>

<p>It is also useful if you would need a look-behind assertion which would contain a non-fixed length pattern (see further on). As variable-length lookbehind is not allowed in Boost&rsquo;s regular expressions, you can use the <code>\K</code> syntax, instead. For instance, the non-allowed syntax <code>(?-i)(?&lt;=\d+)abc</code> can be replaced with the correct syntax <code>(?-i)\d+\Kabc</code> which matches the exact string <code>abc</code> only if preceded by, at least, one digit.</p>

<p><em>Note</em>: Because of the way that Notepad++&rsquo;s replacement works with <code>\K</code>, if your regex <strong>Find what</strong> includes <code>\K</code>, you will <em>not</em> be able to use just <strong>Replace</strong> to replace a single instance of the match; you must use <strong>Replace All</strong> to replace all the matches.  You may use the <strong>Find Next</strong> button to see where an individual replacement will occur, to verify your expression, but you cannot do the replacements one at a time.</p></li>
</ul>

<h4 id="assertions">Assertions</h4>

<p>These special groups consume no characters. Their successful matching counts, but when they are done, matching starts over where it left.</p>

<ul>
<li><p><code>(?=pattern)</code> ⇒ positive lookahead: If <em>pattern</em> matches, backtrack to start of <em>pattern</em>. This allows using logical AND for combining regexes.</p>

<ul>
<li><p>The expression <code>(?=.*[[:lower:]])(?=.*[[:upper:]]).{6,}</code> tries finding a lowercase letter anywhere. On success it backtracks and searches for an uppercase letter. On yet another success, it checks whether the subject has at least 6 characters.</p></li>

<li><p><code>q(?=u)i</code> doesn&rsquo;t match <code>quit</code>, because the assertion <code>(?=u)</code> matches the <code>u</code> but does not consume the <code>u</code>, as matching <code>u</code> consumes zero characters, so then trying to match <code>i</code> in the pattern fails, because it is still comparing against the <code>u</code> in the text being searched.</p></li>
</ul></li>

<li><p><code>(?!pattern)</code> ⇒ negative lookahead: Matches if lookahead <em>pattern</em> didn&rsquo;t match.</p></li>

<li><p><code>(?&lt;=pattern)</code> ⇒ positive lookbehind: This assertion matches if <em>pattern</em> matches immediately before the current position in the search.</p></li>

<li><p><code>(?&lt;!pattern)</code> ⇒ negative lookbehind: This assertion matches if <em>pattern</em> does not match immediately before the current position in the search.</p>

<ul>
<li>NOTE: In the lookbehind assertions, <em>pattern</em> has to be of fixed length, so that the regex engine knows where to test the assertion.  Similar constructs for  variable-length lookbehind include:

<ul>
<li>For variable-length lookbehind assertions from a limited set of constant data items, a construct such as <code>((?&lt;=short)|(?&lt;=longer))</code> is viable.  The individual lookbehinds still cannot include <code>+</code> or <code>*</code> or similar variable-length syntax.</li>
<li>If your desired lookbehind is more complicated than that, you can use <code>\K</code> (see above): instead of <code>(?&lt;=a.*b)MATCH</code>, which won&rsquo;t work, use <code>a.*b\KMATCH</code>.  The <code>\K</code> workaround will only work if the desired lookbehind is the first part of your match, because <em>everything</em> before the <code>\K</code> is excluded from the final match.</li>
</ul></li>
</ul></li>
</ul>

<h4 id="backtracking-control-verbs">Backtracking Control Verbs</h4>

<p>These will control how and when the regular expression will &ldquo;backtrack&rdquo; (go back to a previous point in the text and re-try the match with a different alternative or different number of characters consumed by the wildcard).</p>

<ul>
<li><code>(*PRUNE)</code> ⇒ Has no effect unless backtracked onto, in which case all the backtracking information prior to this point is discarded.</li>
<li><code>(*SKIP)</code> ⇒ Behaves the same as <code>(*PRUNE)</code> except that it is assumed that no match can possibly occur prior to the current point in the string being searched. This can be used to optimize searches by skipping over chunks of text that have already been determined can not form a match.</li>
<li><code>(*THEN)</code> ⇒ Has no effect unless backtracked onto, in which case all subsequent alternatives in a group of alternations are discarded.</li>
<li><code>(*COMMIT)</code> ⇒ Has no effect unless backtracked onto, in which case all subsequent matching/searching attempts are abandoned.</li>
<li><code>(*FAIL)</code> ⇒ Causes the match to fail unconditionally at this point, can be used to force the engine to backtrack.</li>
<li><code>(*ACCEPT)</code> ⇒ Causes the pattern to be considered matched at the current point. Any half-open sub-expressions are closed at the current point.</li>
</ul>

<p>These can be confusing, so <a href="https://community.notepad-plus-plus.org/">Notepad++ Community Forum</a>-regular <code>@guy038</code> has written up detailed <a href="https://community.notepad-plus-plus.org/topic/19632/new-backtracking-control-verbs-feature-available-since-notepad-v7-7">descriptions with examples</a> of these verbs, and collected references to other resources to study more about them.</p>

<h3 id="substitutions">Substitutions</h3>

<p>Substitution expressions (the contents of the <strong>Replace with</strong> entry) use similar syntax to the search expression, with the additional features described below.</p>

<p>All characters are treated as literals except for <code>$</code>, <code>\</code>, <code>(</code>, <code>)</code>, <code>?</code>, and <code>:</code>.</p>

<h4 id="substitution-escape-sequences">Substitution Escape Sequences</h4>

<p>Substitutions understand the <a href="#control-characters">Control Characters</a> and <a href="#match-by-character-code">Match by character code</a> syntax described in the <a href="#regex-special-characters-for-searches">Searches</a> section works in both Searches and Substitutions. The following additional escape sequences are recognized only for Substitutions:</p>

<ul>
<li><p><code>\l</code> ⇒ Causes next character to output in lowercase</p></li>

<li><p><code>\L</code> ⇒ Causes next characters to be output in lowercase, until a <code>\E</code> is found.</p></li>

<li><p><code>\u</code> ⇒ Causes next character to output in uppercase</p></li>

<li><p><code>\U</code> ⇒ Causes next characters to be output in uppercase, until a <code>\E</code> is found.</p></li>

<li><p><code>\E</code> ⇒ Puts an end to forced case mode initiated by <code>\L</code> or <code>\U</code>.</p></li>

<li><p><code>$&amp;</code>, <code>$MATCH</code>, <code>${^MATCH}</code>, <code>$0</code>, <code>${0}</code> ⇒ The whole matched text.</p></li>

<li><p><code>$`</code> <!-- `: dont remove this comment; it fixes UDL highlighting of this paragraph -->, <code>$PREMATCH</code>, <code>${^PREMATCH}</code> ⇒ The text between the previous and current match, or the text before the match if this is the first one.</p></li>

<li><p><code>$'</code>, <code>$POSTMATCH</code>, <code>${^POSTMATCH}</code> ⇒ Everything that follows current match.</p></li>

<li><p><code>$^N</code>, <code>$LAST_SUBMATCH_RESULT</code>, <code>${^LAST_SUBMATCH_RESULT}</code> ⇒ Returns what the last matching subexpression matched.</p></li>

<li><p><code>$+</code>, <code>$LAST_PAREN_MATCH</code>, <code>${^LAST_PAREN_MATCH}</code> ⇒ Returns what matched the last subexpression in the pattern, if that subexpression is currently matched by the regex engine.</p></li>

<li><p><code>$$</code> or <code>\$</code> ⇒ Returns literal <code>$</code> character.</p></li>

<li><p><code>$ℕ</code>, <code>${ℕ}</code>, <code>\ℕ</code> ⇒ Returns what matched the ℕth subexpression (numbered capture group), where ℕ is a positive integer (1 or larger).  If ℕ is greater than 9, use <code>${ℕ}</code>.</p>

<ul>
<li>Please note: the <code>\g...</code> and <code>\k...</code> <a href="#capture-groups-and-backreferences">backreference</a> syntaxes found in the Searching section (whether numbered or named groups) only work in the search expression, and are <em>not</em> designed or intended to work for numbered or named groups in the substitution/replacement expression.</li>
</ul></li>

<li><p><code>$+{name}</code> ⇒ Returns what matched subexpression named <em>name</em> (named capture group).</p></li>
</ul>

<p>If not described in this section, <code>\</code> followed by any character will output that literal character.</p>

<h4 id="substitution-grouping">Substitution Grouping</h4>

<p>The parentheses <code>(</code> and <code>)</code> are used for creating lexical groups, and are not part of the output text.  To output literal parentheses, use <code>\(</code> and <code>\)</code>.</p>

<h4 id="substitution-conditionals">Substitution Conditionals</h4>

<p>If you want to make decisions during the replacement (conditional replacement), use one of these variants of the conditional syntax below.</p>

<ul>
<li><code>?ℕYesPattern:NoPattern</code>: where <code>ℕ</code> is a decimal number (one or more decimal digits), and <code>YesPattern</code> and <code>NoPattern</code> are replacement expressions.  If the ℕth numbered group from the search expression was matched, the <code>YesPattern</code> will be used as the output; if not, the <code>NoPattern</code> will be used instead.  <code>YesPattern</code> cannot start with any digits (0-9) in this version of the syntax, because the digits will be interpreted as part of <code>ℕ</code> instead of part of <code>YesPattern</code>; if <code>YesPattern</code> needs to start with one or more digits, use the <code>?{ℕ}</code> variant of the syntax, below.

<ul>
<li>For example: <code>?1george\($1\):gracie</code> ⇒ if the first group from the search was matched, then use the literal text <code>george</code>, followed by the contents of the first match inside literal parentheses; if the first group does not match, use the literal text <code>gracie</code>.</li>
</ul></li>
<li><code>?{ℕ}YesPattern:NoPattern</code>: where <code>ℕ</code> here can be one or more decimal digit, <code>YesPattern</code> and <code>NoPattern</code> are replacement expressions, as above.  This syntax variant will work even if <code>YesPattern</code> needs to start with one or more digits, because the braces around <code>ℕ</code> separate it from <code>YesPattern</code>.

<ul>
<li>For example: <code>?{13}1george\(${13}\):2gracie</code> ⇒ if the thirteenth group from the search was matched, then use the literal text <code>1george</code>, followed by the contents of the thirteenth match inside literal parentheses; if the thirteenth group does not match, use the literal text <code>2gracie</code>.</li>
</ul></li>
<li><code>?{name}YesPattern:NoPattern</code>: where <em>name</em> is the name of a named-match-group, and <code>YesPattern</code> and <code>NoPattern</code> are replacement expressions, as above.

<ul>
<li>For example: <code>?{comedian}george\($+{comedian}\):gracie</code> ⇒ if the group named <em>comedian</em> from the search was matched, then use the literal text <code>george</code>, followed by the contents of the named group inside literal parentheses; if the named group does not match, use the literal text <code>gracie</code>.</li>
</ul></li>
</ul>

<p>By placing the expression inside parentheses, you can separate the conditional from the surrounding replacement: <code>a=?1george:gracie=b</code> would output <code>a=george</code> or <code>a=gracie=b</code>, whereas <code>a=(?1george:gracie)=b</code> shows when the conditional ends, so would be <code>a=george=b</code> or <code>a=gracie=b</code>.</p>

<p>Remember, to include literal parentheses, question marks, or colons in conditional substitution expressions, make sure to escape them as <code>\(</code> or <code>\)</code> or <code>\?</code> or <code>\:</code>.</p>

<h3 id="zero-length-matches">Zero length matches</h3>

<p>In normal or extended mode, there would be no point in looking for text of length 0; however, in regular expression mode, this can often happen. For example, to add something at the beginning of a line, you&rsquo;ll search for &ldquo;^&rdquo; and replace with whatever is to be added.</p>

<p>Notepad++ would select the match, but there is no sensible way to select a stretch zero character long. When this happens, a tooltip very similar to function call tips is displayed instead, with a caret pointing upwards to the empty match.</p>

<h3 id="examples">Examples</h3>

<p>These examples are meant to help better show what the complex regex syntax will accomplish.  Many of these examples, written by Georg Dembowski, have been in previous versions of the documentation for years; they have been updated to match with the modern Notepad++ regular expression syntax.</p>

<p><strong>IMPORTANT</strong></p>

<ul>
<li><p>You have to check the box &ldquo;regular expression&rdquo; in search &amp; replace dialog</p></li>

<li><p>When copying the strings out of here, pay close attention not to have additional spaces before or after them! Otherwise, the tested regex will not match anything!</p></li>
</ul>

<h4 id="example-0">Example 0</h4>

<p>How to replace/delete full lines according to a regex pattern?
Let&rsquo;s say you wish to delete all the lines in a file that contain the word &ldquo;unused&rdquo;, without leaving blank lines in their stead. This means you need to locate the line, remove it all, and additionally remove its terminating newline.</p>

<p>So, you&rsquo;d want to do this:</p>

<ul>
<li>Find: <code>^.*?unused.*?$\R</code></li>
<li>Replace with: nothing, not even a space</li>
</ul>

<p>The regular expression <strong>appears</strong> to always work  is to be read like this:</p>

<ul>
<li><p>assert the start of a line</p></li>

<li><p>match some characters, stopping as early as required for the expression to match</p></li>

<li><p>the string you search in the file, &ldquo;unused&rdquo;</p></li>

<li><p>more characters, again stopping at the earliest necessary for the expression to match</p></li>

<li><p>assert line ends</p></li>

<li><p>A newline character or sequence</p></li>
</ul>

<p>Remember that <code>.*</code> gobbles everything to the end of line if <strong>☐ . matches newline</strong> is off, and everything to the end of file if the option is on!</p>

<p>Well, why is <strong>appears</strong> above in bold letters? Because this expression assumes each line ends with an end of line sequence. This is almost always true, and may fail for the last line in the file. It won&rsquo;t match and won&rsquo;t be deleted.</p>

<p>But the remedy is fairly simple: we translate in regex parlance that the newline should match if it is there. So the correct expression actually is:</p>

<ul>
<li>Find: <code>^.*?unused.*?$\R?</code></li>
</ul>

<p>This is because <code>?</code> makes it match 0 or 1 <code>\R</code>.</p>

<h4 id="example-1">Example 1</h4>

<p>You use a MediaWiki (like Wikipedia) and want to make all headings one level higher, so a H2 becomes a H1 etc.</p>

<ul>
<li><p>Search <code>^=(=)</code></p></li>

<li><p>Replace with <code>\1</code></p></li>

<li><p>Click <strong>Replace all</strong></p></li>
</ul>

<p>You do this to find all headings2&hellip;9 (two equal sign characters are required) which begin at line beginning (^) and to replace the two equal sign characters by only the last of the two, so eliminating one and having one remaining.</p>

<ul>
<li><p>Search <code>=(=)$</code></p></li>

<li><p>Replace with <code>\1</code></p></li>

<li><p>Click <strong>Replace all</strong></p></li>
</ul>

<p>You do this to find all headings2&hellip;9 (two equal sign characters are required) which end at line ending ($) and to replace the two equal sign characters by only the last of the two, so eliminating one and having one remaining.</p>

<p><code>== title ==</code> became <code>= title =</code></p>

<p>You&rsquo;re done :-)</p>

<h4 id="example-2">Example 2</h4>

<p>You have a document with a lot of dates, which are in date format <code>dd.mm.yy</code> and you&rsquo;d like to transform them to sortable format <code>yy-mm-dd</code>. Don&rsquo;t be afraid by the length of the search term – it&rsquo;s long, but consisting of pretty easy and short parts.</p>

<p>Do the following:</p>

<ul>
<li>Search <code>([^0-9.])([0123][0-9])\.([01][0-9])\.([0-9][0-9])([^0-9.])</code> or</li>
</ul>

<p>Search <code>(\s)([0123][0-9])\.([01][0-9])\.([0-9][0-9])(\s)</code></p>

<ul>
<li><p>Replace with <code>\1\4-\3-\2\5</code></p></li>

<li><p>Click <strong>Replace all</strong></p></li>
</ul>

<p>You do this to fetch:</p>

<ul>
<li><p>the day, whose first number can only be 0, 1, 2 or 3</p></li>

<li><p>the month, whose first number can only be 0 or 1</p></li>

<li><p>but only if the separator is a literal dot and not any standard character ( <code>\.</code> versus <code>.</code> )</p></li>

<li><p>but only if no numbers are surrounding the date, as then it might be an IP address instead of a date</p></li>
</ul>

<p>and to write all of this in the opposite order, except for the surroundings. Pay attention: Whatever SEARCH matches will be deleted and only replaced by the stuff in the REPLACE field, thus it is mandatory to have the surroundings in the REPLACE field as well!</p>

<p>Outcome:</p>

<ul>
<li><p><code>31.12.97</code> became <code>97-12-31</code></p></li>

<li><p><code>14.08.05</code> became <code>05-08-14</code></p></li>

<li><p>the IP address <code>14.13.14.14</code> did not change</p></li>
</ul>

<p>You&rsquo;re done :-)</p>

<h4 id="example-3">Example 3</h4>

<p>You have printed in windows a file list using <code>dir /a-d /b/s /-p &gt; filelist.txt</code> to the file filelist.txt and want to make local URLs out of them.</p>

<ul>
<li><p>Open <code>filelist.txt</code> with Notepad++</p></li>

<li><p>Search <code>\\</code></p></li>

<li><p>Replace with <code>/</code></p></li>

<li><p>Click <strong>Replace all</strong>.</p>

<p>This changes the Windows path separator char <code>\</code> into the URL path separator char <code>/</code></p></li>

<li><p>Search <code>\x20</code></p></li>

<li><p>Replace <code>%20</code></p></li>

<li><p>Click <strong>Replace all</strong> to change any space character into the <code>%20</code> syntax</p>

<p>According on your requirements, you can similarly change any possible symbol <code>! # $ % &amp; ' ( ) + , - ; = @ [ ] ^ { } ~</code> with the appropriate <code>%ℕℕ</code> expression</p></li>

<li><p>Search <code>^(?=.)</code></p></li>

<li><p>Replace with <code>file:///</code></p></li>

<li><p>Click <strong>Replace all</strong></p>

<p>This adds file:/// to the beginning of all non-empty lines</p></li>
</ul>

<p>After this sequence, <code>C:\!\Test A.csv</code> became <code>file:///C:/!/Test%20A.csv</code>.</p>

<p>You&rsquo;re done :-)</p>

<h4 id="example-4">Example 4</h4>

<p>Let’s suppose you need a comma delimited table from the table, below :</p>

<pre><code>[Data]
AS AF AFG 004 Afghanistan
EU AX ALA 248 Åland Islands
EU AL ALB 008 Albania, People's Socialist Republic of
AF DZ DZA 012 Algeria, People's Democratic Republic of
OC AS ASM 016 American Samoa
EU AD AND 020 Andorra, Principality of
AF AO AGO 024 Angola, Republic of
NA AI AIA 660 Anguilla
AN AQ ATA 010 Antarctica (the territory South of 60 deg S)
NA AG ATG 028 Antigua and Barbuda
SA AR ARG 032 Argentina, Argentine Republic
AS AM ARM 051 Armenia
NA AW ABW 533 Aruba
OC AU AUS 036 Australia, Commonwealth of
</code></pre>

<p>Then use the following regex S/R :</p>

<ul>
<li><p>Search for: <code>(?-i)[\u\d]\K\x20(?=[\u\d])</code></p></li>

<li><p>Replace with: <code>,</code></p></li>

<li><p>Hit <strong>Replace All</strong></p>

<pre><code>[Final Data]
AS,AF,AFG,004,Afghanistan
EU,AX,ALA,248,Åland Islands
EU,AL,ALB,008,Albania, People's Socialist Republic of
AF,DZ,DZA,012,Algeria, People's Democratic Republic of
OC,AS,ASM,016,American Samoa
EU,AD,AND,020,Andorra, Principality of
AF,AO,AGO,024,Angola, Republic of
NA,AI,AIA,660,Anguilla
AN,AQ,ATA,010,Antarctica (the territory South of 60 deg S)
NA,AG,ATG,028,Antigua and Barbuda
SA,AR,ARG,032,Argentina, Argentine Republic
AS,AM,ARM,051,Armenia
NA,AW,ABW,533,Aruba
OC,AU,AUS,036,Australia, Commonwealth of
</code></pre></li>
</ul>

<p>You’re done :-)</p>

<h4 id="example-5">Example 5</h4>

<p>How to recognize a balanced expression, in mathematics or in programming?</p>

<p>First, let&rsquo;s give some example data:</p>

<pre><code>[Sample Test Start]

((((ab(((cd((()))))ef))))))
0000  000  00100000  00000•
1234  567  89098765  43210


((ab((((cd(((ef(()))))gh))))ijkl))))
00  0000  000  1110000  0000    00••
12  3456  789  0109876  5432    10


((((((ab(cd(ef((()))))gh)ijkl)))mn)))))
000000  0  0  01110000  0    000  00•••
123456  7  8  90109876  5    432  10


((01ab(cd(ef23gh(ij45kl)mn)op((qr67st)uv\wx)34)yz))128956)abc
12    3  4      5      4  3  45      4     3  2  10      •

[[@ab[cd{ef@gh{ij@kl}mn]op((qr@st}uv@x]34yz])12@56)[cdedf]
                          12                1     0

((12ab(cd{ef34gh{ij56kl}mn}123}op((qr78stu)v\wx34)yz)12905126]
12    3                          45       4      3  2
••

[[@ab[cd{ef@gh{ij@kl}mn}123]op((qr@stu)v@x34)yz]12@5@6]
                              12      1     0
[Sample Test End]
</code></pre>

<p>For instance, let’s try to build a regular expression that finds the largest range of text with well-balanced parentheses!</p>

<p>First, some typographic conventions:</p>

<ul>
<li><p>Let Sp be a starting parenthesis. So, its regex syntax is the escaped form <code>\(</code>, or simply <code>(</code> if inside a character class</p></li>

<li><p>Let Ep be an ending parenthesis. So, its regex syntax is the escaped form <code>\)</code>, or simply <code>)</code> if inside a character class</p></li>

<li><p>Let Ac be any single allowed character, including EOF character(s), different from EP and SP. So, its regex syntax is the negative class character <code>[^EpSp]</code>, i.e., the negative class character <code>[^()]</code></p></li>

<li><p>Let R0 be a recursion to the whole matched pattern. By convention, in PCRE, its regex syntax is <code>(?0)</code> or <code>(?R)</code></p></li>

<li><p>Let R1 be a recursion to the group 1 pattern. By convention, in PCRE, its regex syntax is <code>(?1)</code></p></li>

<li><p>Now , let Bb be a well-balanced block, containing an Ep&hellip;.Sp construction, itself possibly composed with, both, Ac characters and an other Bb, at any level greater than level 0</p>

<p>This Bb block can be represented by the symbolic regex, below ( Blank chars are ignored, for readability ) :</p>

<pre><code>Sp ( Ac+ | R0 )* Ep
</code></pre>

<p>This syntax may be improved as <code>Bb = Sp (?: Ac++ | R0 )* Ep</code>, using, both :</p></li>

<li><p>A non-capturing group, surrounding the two alternatives</p></li>

<li><p>A possessive quantifier relative to the Ac character, to be similar to the atomic state of recursions, in PCRE.</p>

<p>It is important to point out that, if you would use the greedy form <code>Ac+</code>, instead of <code>Ac++</code>, the last match would be, wrongly, all the file contents, even against a very short text! Again, the advantage of not allowing backtracking reduces combinations and avoids the catastrophic backtracking process :-)</p></li>
</ul>

<p>Now, more precisely, between the Sp and Ep parentheses, you may meet:</p>

<ul>
<li><p>Nothing, hence the star quantifier, after the non-capturing group</p></li>

<li><p>A non-null range of allowed chars, so the atomic group Ac++</p></li>

<li><p>Another well-balanced Bb construction which can be verified, in turn, by the recursion feature R0</p></li>
</ul>

<p>On the other hand, any subject text scanned can be defined, either, as:</p>

<ul>
<li><p>A combination of successive syntaxes  Ac*  Bb  Ac*  Bb  Ac*  Bb, ended with a last Ac* . So, in the symbolic regex syntax, this can be written as (?: Ac* Bb)+ Ac*</p></li>

<li><p>A non-null range of allowed chars, when the subject text does NOT contain any Ep and Sp parenthesis, so the Ac+ symbolic syntax, only ( By extension, a text without parentheses is, obviously, a well-balanced parentheses text&hellip; as it contains no parenthesis ! )</p></li>
</ul>

<p>This implies that the general symbolic regex is <code>(?: Ac* Bb )+ Ac* | Ac+</code></p>

<p>Now, by substituting the above value of the well-balanced Bb construction, in our final expression, we get our final symbolic regex expression :</p>

<pre><code>(?: Ac* ( Sp (?: Ac++ | R1 )* Ep ) )+ Ac* | Ac+
        \ ---------------------- /
                 Group 1
</code></pre>

<p>Note, however, that we just had to add two parentheses to define a new group #1 , which embeds the Bb construction,. Indeed, during the recursion process, it must refer, specifically, to that group #1 and NOT recurse to the whole regex pattern. Hence, the R1 notation, instead of the R0 notation!</p>

<p>Finally, we can get something more legible if we use the free-spacing mode to identify the components of our regex and rewrite this expression with the correct regex syntax:</p>

<pre><code>(?x) (?: [^()]*  (  \(  (?:  [^()]++  |  (?1)  )*  \)  )  )+  [^()]*  |  [^()]+
</code></pre>

<p>Note that, with the free-spacing mode, you may, as well, insert comments and split the regex on several lines, leading, for instance, to the following text:</p>

<pre><code>(?x)                  #  FREE-SPACING mode
(?:                   #  Start of the FIRST NON-CAPTURING group
    [^()]*            #      Any range, possibly NUL, of ALLOWED characters
    (                 #      Start of CAPTURING group #1
        \(            #          STARTING parenthesis
        (?:           #          Start of the SECOND NON-CAPTURING group
            [^()]++   #              Any NON-NULL ATOMIC range of ALLOWED characters,
            |         #              OR
            (?1)      #              A RECURSION, using the regex pattern of group #1
        )*            #          End of the SECOND NON-CAPTURING group, repeated 0 or MORE times
        \)            #          ENDING parenthesis
    )                 #      End of the CAPTURING group 1
)+                    #  End of the FIRST NON-CAPTURING group, repeated 1 or MORE times
[^()]*                #  Any range, possibly NUL, of ALLOWED characters
|                     #  OR
[^()]+                #  Any NON-NULL range of ALLOWED characters,
</code></pre>

<p>If we reduce the syntax of this recursive regular expression to its minimum, we get :</p>

<pre><code>(?:[^()]*(\((?:[^()]++|(?1))*\)))+[^()]*|[^()]+
</code></pre>

<p>But it is about as hard to decrypt as a badly indented piece of code without a comment and with unpromising, unclear identifiers.</p>

<h4 id="example-6">Example 6</h4>

<p>This example gives more insight into using independent sub-expressions to prevent back-tracking when using Conditional Expressions.</p>

<p>Given the file:</p>

<pre><code>  5 apples in a box
100 apples in a box
200 apples in a barrel
250 apples in a box
500 apples in a barrel
</code></pre>

<p>We want to match when there are 250 or fewer apples only when they are in a box; if there are more apples than 250, it should only match in a barrel.  Thus, <code>200 apples in a barrel</code> should <em>not</em> match.</p>

<p>First we need to construct a Conditional Expression for apples container:</p>

<pre><code>(?('LEQ250')in a box|in a barrel)
</code></pre>

<p>The <code>('LEQ250')</code> refers to some Capture Group which will catch quantity of apples comparing with our condition:</p>

<pre><code>(?:(?'LEQ250'\d{1,2}|1\d\d|2[0-4]\d|250)|\d+)\D
</code></pre>

<p>The trick here is that if we have alternatives in this Capture Group, we can&rsquo;t allow search to back-track to try a different alternative from the condition when the conditional fails.  Thus, we need to use an Independent sub-expression:</p>

<pre><code>(?&gt;(?:(?'LEQ250'\d{1,2}|1\d\d|2[0-4]\d|250)|\d+)\D)
</code></pre>

<p>But if we use Independent sub-expression we have other two problems:</p>

<ol>
<li>we have possibility for spaces appear before digits <code>\h*</code></li>
<li>we need to check where number ends <code>\D</code></li>
</ol>

<p>Alternatives and Multiplying Operators need backtracking and so must be resolved inside the Independent sub-expression.  In our example <code>\h*\d</code> is definitive - <code>\h*</code> always stops before non-space (and a digit <code>\d</code> is not a space), but if you need to include some alternatives or multiplying operators inside your capture group, then include all of them, to give the Independent sub-expression the possibility to backtrack within itself.</p>

<p>It is better to check for the end in a more general form, in order to not include patterns not needed for Capture Group inside Independent sub-expression; thus, we will use the positive lookahead (?=\D) Assertion.</p>

<p>As a result we have the following regexp:</p>

<pre><code>^\h*(?&gt;(?:(?'LEQ250'\d{1,2}|1\d\d|2[0-4]\d|250)|\d+)(?=\D)) apples (?('LEQ250')in a box|in a barrel)
</code></pre>

<p>With this expression, our search results are</p>

<pre><code>File1 (4 hits)
Line 1: 5 apples in a box
Line 2: 100 apples in a box
Line 4: 250 apples in a box
Line 5: 500 apples in a barrel
</code></pre>

<p>If we didn&rsquo;t use the Independent sub-expression, and instead used the regex</p>

<pre><code>^\h*(?:(?:(?'LEQ250'\d{1,2}|1\d\d|2[0-4]\d|250)|\d+)(?=\D)) apples (?('LEQ250')in a box|in a barrel)
</code></pre>

<p>Our search results would incorrectly match line 3 (<code>200 apples in a barrel</code>):</p>

<pre><code>File1 (5 hits)
Line 1: 5 apples in a box
Line 2: 100 apples in a box
Line 3: 200 apples in a barrel
Line 4: 250 apples in a box
Line 5: 500 apples in a barrel
</code></pre>

<h2 id="searching-actions-when-recorded-as-macros">Searching actions when recorded as macros</h2>

<p>The Find family of actions can be recorded in a macro to make them easy to name and later replay via the <strong>Macro</strong> menu or an assigned keyboard shortcut.  Somewhat unfortunately, <strong>Find what</strong> and <strong>Replace with</strong> text is hardwired into the macro when it is created, and isn&rsquo;t something the user can change when the macro runs, but often this isn&rsquo;t a significant limitation.</p>

<p>Note, however, that Find-related actions are recorded a bit differently than other Notepad++ actions, so we&rsquo;ll discuss them a bit more in-depth here.  Typically, Notepad++ will record a step in a macro every time a user does something in the Notepad++ user interface.  The Find family of actions is more &ldquo;coordinated&rdquo; where macro recording is concerned.</p>

<p>The macro recorder only records when an actual Find family action (e.g. <strong>Replace</strong>, <strong>Find All in Current Document</strong>, etc.) occurs.  Thus you can tweak a future action&rsquo;s parameters (e.g. <strong>Match case</strong>, <strong>Wrap around</strong>, etc.) all you&rsquo;d like, and all of that fiddling doesn&rsquo;t get remembered.  At the point where you perform an action, then a snapshot is taken of all of the parameters and the action, and this is logged in the macro memory as a proper macro sequence.</p>

<p>While the user can simply record and use Find family macros, one can also edit those macros later to change or add to their functionality, so it is helpful to know the details of the macro sequences that were previously recorded.  While the details of how macros in general are recorded and stored in <em>shortcuts.xml</em> is discussed elsewhere, here are the details of what happens when Notepad++ saves a recorded Find family macro:</p>

<p>First comes a <strong>1700</strong> message which carries out some initialization of the Find engine:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1700&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;&quot; /&gt;</code></p>

<p>Next is a <strong>1601</strong> message with the <strong>Find what</strong> text in the <strong>sParam</strong> field; in this example we search for &ldquo;it&rdquo;:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1601&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;it&quot; /&gt;</code></p>

<p>Following that is a <strong>1625</strong> message with the <strong>Search mode</strong> in <strong>lParam</strong>, with possible values of 0=<strong>Normal</strong> / 1=<strong>Extended</strong> / 2=<strong>Regular expression</strong>; let&rsquo;s show <strong>Regular expression</strong> in this example:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1625&quot; wParam=&quot;0&quot; lParam=&quot;2&quot; sParam=&quot;&quot; /&gt;</code></p>

<p>After that, if a type of replacement operation is being performed, is a <strong>1602</strong> message with <strong>sParam</strong> holding the <strong>Replace with</strong> text; here we&rsquo;ll make that &ldquo;IT&rdquo;:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1602&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;IT&quot; /&gt;</code></p>

<p>Moving on, next, if performing a <strong>Find All</strong> (really a Find-in-Files) or a <strong>Replace in Files</strong>, is a <strong>1653</strong> message containing the base <strong>Directory</strong> for the search in <strong>sParam</strong>:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1653&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;C:\Program Files\Notepad++\&quot; /&gt;</code></p>

<p>Also when doing a <strong>Find All</strong> or a <strong>Replace in Files</strong>, will be a <strong>1652</strong> message containing the <strong>Filters</strong> for the search in <strong>sParam</strong>:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1652&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;*.*&quot; /&gt;</code></p>

<p>Next will be a <strong>1702</strong> message that contains a bit-weighted number in <strong>lParam</strong> that represents the &ldquo;checkbox&rdquo; option parameters for the action (more on this later, for now we will just use 515 in the example, and present the bit-weight table):</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1702&quot; wParam=&quot;0&quot; lParam=&quot;515&quot; sParam=&quot;&quot; /&gt;</code></p>

<table>
<thead>
<tr>
<th align="right">1702-Bit-Weight</th>
<th align="right">Binary-Bit-Weight</th>
<th align="left">Meaning (equivalent option checked)</th>
<th align="left">Alternate Meaning (²)</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">1</td>
<td align="right">0000-0000-0001</td>
<td align="left">Match whole word only</td>
<td align="left"></td>
</tr>

<tr>
<td align="right">2</td>
<td align="right">0000-0000-0010</td>
<td align="left">Match case</td>
<td align="left"></td>
</tr>

<tr>
<td align="right">4</td>
<td align="right">0000-0000-0100</td>
<td align="left">Purge for each search</td>
<td align="left"></td>
</tr>

<tr>
<td align="right">16</td>
<td align="right">0000-0001-0000</td>
<td align="left">Bookmark line</td>
<td align="left"></td>
</tr>

<tr>
<td align="right">32</td>
<td align="right">0000-0010-0000</td>
<td align="left">In all sub-folders</td>
<td align="left"></td>
</tr>

<tr>
<td align="right">64</td>
<td align="right">0000-0100-0000</td>
<td align="left">In hidden folders</td>
<td align="left"></td>
</tr>

<tr>
<td align="right">128</td>
<td align="right">0000-1000-0000</td>
<td align="left">In selection</td>
<td align="left">Project Panel 1 (²)</td>
</tr>

<tr>
<td align="right">256</td>
<td align="right">0001-0000-0000</td>
<td align="left">Wrap around</td>
<td align="left">Project Panel 2 (²)</td>
</tr>

<tr>
<td align="right">512</td>
<td align="right">0010-0000-0000</td>
<td align="left">Backward direction (¹)</td>
<td align="left">Project Panel 3 (²)</td>
</tr>

<tr>
<td align="right">1024</td>
<td align="right">0100-0000-0000</td>
<td align="left">. matches newline</td>
<td align="left"></td>
</tr>
</tbody>
</table>

<p>¹: <strong>Backward direction</strong> checked means 512 is <em>not</em> included; unchecked means 512 <em>is</em> included.</p>

<p>²: <strong>Project Panel &ldquo;alternate meaning&rdquo;</strong> column shows the meaning for those bits when the action <strong>1701</strong> message (below) is set to <strong>Find All</strong> (in Projects) or <strong>Replace in Projects</strong>.</p>

<blockquote>
<p>Let&rsquo;s see how the example value 515 used above is decoded:</p>

<p>lParam=&ldquo;515&rdquo; (decimal) = 203 (hex) = 0010 0000 0011 (binary) = 512 + 2 + 1 = (<strong><em>not</em></strong> Backward direction + Match case + Match whole word only).  Thus, this would represent a forward-from-caret-towards-end-of-file search of exact case specified, with the additional qualifier that the match text must be bracketed by non-word characters.</p>
</blockquote>

<p>The last message in the sequence is a <strong>1701</strong> message, which encodes the Find family action to perform in <strong>lParam</strong>, which, when executed will conduct the action using all of the information encoded in the prior messages; let&rsquo;s do a <strong>Replace in Files</strong>, which has an integer value of 1660, for purposes of an example:</p>

<p><code>&lt;Action type=&quot;3&quot; message=&quot;1701&quot; wParam=&quot;0&quot; lParam=&quot;1660&quot; sParam=&quot;&quot; /&gt;</code></p>

<table>
<thead>
<tr>
<th align="right">1701-Value</th>
<th>Meaning (equivalent button press)</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">1</td>
<td>Find Next</td>
</tr>

<tr>
<td align="right">1608</td>
<td>Replace</td>
</tr>

<tr>
<td align="right">1609</td>
<td>Replace All</td>
</tr>

<tr>
<td align="right">1614</td>
<td>Count</td>
</tr>

<tr>
<td align="right">1615</td>
<td>Mark All</td>
</tr>

<tr>
<td align="right">1633</td>
<td>Clear all marks</td>
</tr>

<tr>
<td align="right">1635</td>
<td>Replace All in All Opened Documents</td>
</tr>

<tr>
<td align="right">1636</td>
<td>Find All in All Opened Documents</td>
</tr>

<tr>
<td align="right">1641</td>
<td>Find All in Current Document</td>
</tr>

<tr>
<td align="right">1656</td>
<td>Find All (in Files)</td>
</tr>

<tr>
<td align="right">1660</td>
<td>Replace in Files</td>
</tr>

<tr>
<td align="right">1665</td>
<td>Replace in Projects</td>
</tr>

<tr>
<td align="right">1666</td>
<td>Find All (in Projects)</td>
</tr>
</tbody>
</table>

<p>Here is a complete example (that could occur in <em>shortcuts.xml</em>) and how it is interpreted:</p>

<pre><code>&lt;Macro name='Book Mark lines NOT containing ABC' Ctrl=&quot;no&quot; Alt=&quot;no&quot; Shift=&quot;no&quot; Key=&quot;0&quot;&gt;
    &lt;Action type=&quot;3&quot; message=&quot;1700&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;&quot; /&gt;
    &lt;Action type=&quot;3&quot; message=&quot;1601&quot; wParam=&quot;0&quot; lParam=&quot;0&quot; sParam=&quot;^(?-s)(?!.*ABC).*&quot; /&gt;
    &lt;Action type=&quot;3&quot; message=&quot;1625&quot; wParam=&quot;0&quot; lParam=&quot;2&quot; sParam=&quot;&quot; /&gt;
    &lt;Action type=&quot;3&quot; message=&quot;1702&quot; wParam=&quot;0&quot; lParam=&quot;786&quot; sParam=&quot;&quot; /&gt;
    &lt;Action type=&quot;3&quot; message=&quot;1701&quot; wParam=&quot;0&quot; lParam=&quot;1615&quot; sParam=&quot;&quot; /&gt;
&lt;/Macro&gt;
</code></pre>

<p>First we have our initializing 1700 message.</p>

<p>Following that in the 1601 message&rsquo;s sParam field is a regular expression that will match lines that do not contain &ldquo;ABC&rdquo;: <code>^(?-s)(?!.*ABC).*</code></p>

<p>The search type for &ldquo;Regular expression&rdquo; appears next as lParam=&ldquo;2&rdquo; in the 1625 message.</p>

<p>Skipping the 1702 message for the moment, the 1701 message has lParam=&ldquo;1615&rdquo; which, from the 1701 table, means &ldquo;Mark All&rdquo;.</p>

<p>Finally, let&rsquo;s consider the 1702 message.  Its pertinent part is lParam=&ldquo;786&rdquo;.  The best way to break that down into its component parts is to convert the number to binary and then determine how the one-bits in the binary contribute to the meaning.  786 in binary is 1100010010 (= 512 + 256 + 16 + 2), which breaks down as follows, and then reading the 1702 table from earlier we get the contributors to functionality:</p>

<ul>
<li><p><code>1000000000</code> = 512 - Backward direction <em>disabled</em> (thus forward direction from caret toward bottom end of file)</p></li>

<li><p><code>0100000000</code> = 256 - Wrap around</p></li>

<li><p><code>0000010000</code> = 16 - Bookmark line</p></li>

<li><p><code>0000000010</code> = 2 - Match case</p></li>
</ul>

<p>Note that in this example we seem to have conflicting search parameters:  We have a direction encoded, as well as a Wrap around, which nullifies the need for a direction.  This is not a problem, as the Wrap around option will take precedence, just like in a non-macro&rsquo;d interactive searching operation.</p>
</article>

      

      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#dialog-based-searching">Dialog-based Searching</a>
<ul>
<li><a href="#find-replace-tabs">Find / Replace tabs</a></li>
<li><a href="#find-in-files-tab">Find in Files tab</a></li>
<li><a href="#find-in-projects-tab">Find in Projects tab</a></li>
<li><a href="#mark-tab">Mark tab</a>
<ul>
<li><a href="#bookmarks-vs-marks">Bookmarks vs Marks</a></li>
</ul></li>
<li><a href="#search-results-window">Search results window</a>
<ul>
<li><a href="#rightclick-commands-in-the-client-area-of-a-search-results-window-s-tab"><code>RightClick</code> commands in the client area of a <strong>Search results</strong> window&rsquo;s tab</a>
<ul>
<li><a href="#copying-text-from-the-search-results-window">Copying text from the <strong>Search results</strong> window</a></li>
<li><a href="#other-commands">Other commands</a></li>
<li><a href="#searching-in-previously-found-results-secondary-searching">Searching in previously-found results (secondary searching)</a></li>
<li><a href="#search-results-configuration-options">Search results configuration options</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#dialog-free-search-mark-actions">Dialog-free search/mark actions</a>
<ul>
<li><a href="#searching">Searching</a>
<ul>
<li><a href="#comparison-between-select-and-find-next-and-find-volatile-next"><em>Comparison between &ldquo;Select and Find Next&rdquo; and &ldquo;Find (Volatile) Next&rdquo;</em></a></li>
</ul></li>
<li><a href="#marking-with-a-color-style-and-highlighting">Marking with a color/style and Highlighting</a></li>
<li><a href="#manipulating-bookmarks">Manipulating Bookmarks</a></li>
<li><a href="#change-history">Change History</a></li>
</ul></li>
<li><a href="#finding-characters-in-a-specific-range">Finding characters in a specific range</a></li>
<li><a href="#incremental-search">Incremental Search</a></li>
<li><a href="#extended-search-mode">Extended Search Mode</a></li>
<li><a href="#regular-expressions">Regular Expressions</a>
<ul>
<li><a href="#regex-special-characters-for-searches">Regex Special Characters for Searches</a>
<ul>
<li><a href="#single-character-matches">Single-character matches</a>
<ul>
<li><a href="#match-by-character-code">Match by character code</a></li>
<li><a href="#collating-sequences">Collating Sequences</a></li>
<li><a href="#control-characters">Control characters</a></li>
<li><a href="#special-control-escapes">Special Control escapes</a></li>
</ul></li>
<li><a href="#ranges-or-kinds-of-characters">Ranges or kinds of characters</a>
<ul>
<li><a href="#character-classes">Character Classes</a></li>
<li><a href="#character-properties">Character Properties</a></li>
<li><a href="#character-escape-sequences">Character escape sequences</a></li>
<li><a href="#equivalence-classes">Equivalence Classes</a></li>
</ul></li>
<li><a href="#multiplying-operators">Multiplying operators</a></li>
<li><a href="#anchors">Anchors</a></li>
<li><a href="#capture-groups-and-backreferences">Capture Groups and Backreferences</a></li>
<li><a href="#readability-enhancements">Readability enhancements</a></li>
<li><a href="#search-modifiers">Search modifiers</a></li>
</ul></li>
<li><a href="#control-flow">Control flow</a>
<ul>
<li><a href="#assertions">Assertions</a></li>
<li><a href="#backtracking-control-verbs">Backtracking Control Verbs</a></li>
</ul></li>
<li><a href="#substitutions">Substitutions</a>
<ul>
<li><a href="#substitution-escape-sequences">Substitution Escape Sequences</a></li>
<li><a href="#substitution-grouping">Substitution Grouping</a></li>
<li><a href="#substitution-conditionals">Substitution Conditionals</a></li>
</ul></li>
<li><a href="#zero-length-matches">Zero length matches</a></li>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#example-0">Example 0</a></li>
<li><a href="#example-1">Example 1</a></li>
<li><a href="#example-2">Example 2</a></li>
<li><a href="#example-3">Example 3</a></li>
<li><a href="#example-4">Example 4</a></li>
<li><a href="#example-5">Example 5</a></li>
<li><a href="#example-6">Example 6</a></li>
</ul></li>
</ul></li>
<li><a href="#searching-actions-when-recorded-as-macros">Searching actions when recorded as macros</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
<script data-no-instant>document.write('<script src="../../livereloada582.js?port=1313&amp;mindelay=10&amp;v=2"></' + 'script>')</script></body>


<!-- Mirrored from 127.0.0.1:1313/docs/searching/ by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 18 Dec 2023 19:41:38 GMT -->
</html>
